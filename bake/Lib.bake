import System
import System.IO
import System.Xml.Linq
import System.Diagnostics
import System.Xml.XPath.Extensions
import System.Xml.Serialization from System.XML
import System.Linq.Enumerable from System.Core
import System.Collections.Generic
import file from Svn.boo

class Library:
	property Name as string
	property LibVersion as string
	property InstallPath as string

	def constructor(name as string):
		Name = name
		if Name.Contains("/"):
			LibVersion = Name[Name.IndexOf("/") + 1:]
			Name = Name[:Name.IndexOf("/")]

	def RemoveOldVersion():
		return unless LibVersion
		path = Path.GetDirectoryName(InstallPath)
		for dir in Directory.GetDirectories(path):
			version as Version
			if Version.TryParse(Path.GetFileName(dir), version):
				if Version(LibVersion) != version:
					print "Remove old $Name $version"
					RmDir(dir, true)

[XmlRoot(Namespace: "http://schemas.microsoft.com/developer/msbuild/2003")]
class Project:
	property PropertyGroup as PropertyGroup

class PropertyGroup:
	property LibPath as string
	property PackagePath as string
	property ReferencePath as string

libRoot = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "../lib/")

def ParseFromPackageName(dir as string):
	name = Path.GetFileName(dir)
	match = /(\.\d+){2,4}$/.Match(name)
	return null unless match.Success
	return /(\.\d+){2,4}$/.Replace(name, /^\./.Replace(match.Value, "/"))

def ParseFromLib(dir as string):
	posibleVersion = Directory.GetDirectories(dir).FirstOrDefault()
	versionValue as Version
	return null unless Version.TryParse(posibleVersion, versionValue)
	name = Path.GetFileName(dir)
	version = posibleVersion
	return "$name/$version"

def ReadInstalled():
	libs = List of string()
	if Exist("packages"):
		libs.AddRange(Directory.GetDirectories("packages")\
			.Select({d| ParseFromPackageName(d)})\
			.Where({d| d is not null}))
	if Exist("lib"):
		libs.AddRange(Directory.GetDirectories("lib")\
			.Select({d| ParseFromPackageName(d)})\
			.Where({d| d is not null}))
	return libs

def GetMaxLibVersion(libPath as string):
	version as string
	if not Directory.GetFiles(libPath).Length:
		for d in Directory.GetDirectories(libPath):
			name = Path.GetFileName(d)
			currentVersion = Version(name)
			if not version:
				version = name
			elif Version(version) < currentVersion:
				version = name
	return version

def InstallLib(lib as string, installed as List of string):
	if lib.Contains(" "):
		lib = lib.Replace(" ", "/")

	libPath = Path.GetFullPath(Path.Combine(libRoot, lib))
	if not Exist(libPath):
		raise "Library ${libPath} not exists"

	version as string
	if lib.Contains("/"):
		version = lib[lib.IndexOf("/") + 1:]

	unless version:
		version = GetMaxLibVersion(libPath)
		if version:
			lib += "/" + version

	libPath = Path.Combine(libRoot, lib)
	installPath = Path.GetFullPath("lib/$lib")

	if installed.Contains(lib):
		return

	Cp(FileSet("**.*", BaseDirectory : libPath, Excludes : ["**/.svn/**", "deps"]), installPath, true)
	installed.Add(lib)
	print "Library ${lib} installed into $installPath"
	Library(lib, InstallPath: installPath).RemoveOldVersion()
	depFile = "${libPath}/deps"
	if Exist(depFile):
		for dep in File.ReadAllLines(depFile):
			InstallLib(dep, installed)

def IsValidPath(path as string, libPath as string):
	return true if path.IndexOf("\\packages\\") < 0
	return false if path.IndexOf("LibPath") >= 0
	return Exist(path.Replace('$(PackagePath)', libPath))

def CleanUp(value as string, libPath as string):
	return value unless value
	paths = value.Split(char(';'))
	return String.Join(";", paths.Where({p| IsValidPath(p, libPath)}))

def ReferencePath(prefix as string, libs as string*):
	return String.Join(";", libs.Select({l| '$(' + prefix + ')\\' + l}).ToArray())

def BuildLibProperties(prefix as string, filename as string, libPath as string, paths as string*):
	xmlNamespace = XNamespace.Get("http://schemas.microsoft.com/developer/msbuild/2003")
	if Exist(filename):
		document = XDocument.Load(filename)
		element = document.Descendants().First({e| e.Name.LocalName == @ReferencePath})
		value = CleanUp(element.Value, libPath)
		libs = paths.Where({p| value.IndexOf(p) < 0})
		element.Value = value + ";" + ReferencePath(prefix, libs)

		unless document.Descendants().FirstOrDefault({e| e.Name.LocalName == prefix}):
			propertyGroup = document.Descendants().First({e| e.Name.LocalName == @PropertyGroup})
			propertyGroup.AddFirst(XElement(xmlNamespace + prefix, libPath))

		document.Save(filename)
	else:
		document = XDocument(XElement(xmlNamespace + @Project,\
			XElement(xmlNamespace + @PropertyGroup,\
				XElement(xmlNamespace + prefix, libPath),\
				XElement(xmlNamespace + @ReferencePath, ReferencePath(prefix, paths)))))
		document.Save(filename)

def Import():
	importPath = "..\\ProjectLib.properties"
	for dir in Directory.GetDirectories("src"):
		for file in Directory.GetFiles(dir, "*.*proj"):
			document = XDocument.Load(file)
			projectNode = document.Elements().First()
			importNode = projectNode.Elements().FirstOrDefault({e| e.Name.LocalName == @Import and\
				e.Attribute(@Project).Value == importPath})
			unless importNode:
				importNode = XElement(projectNode.Name.Namespace + @Import,\
					XAttribute(@Project, importPath),\
					XAttribute(@Condition, "Exists('$importPath')"))
				projectNode.AddFirst(importNode)
				document.Save(file)

def CheckPlatformSpecificVersion(path as string):
	preferedVersions = ["net40", "NET40ClientProfile", "net35", "20", "2.0", "net"]
	specificVersion = preferedVersions.Select({v| Path.Combine(path, v)}).FirstOrDefault({d| Directory.Exists(d)})
	if specificVersion:
		return specificVersion
	else:
		return path

def GetLibPath(dir as string):
	subdirs = Directory.GetDirectories(dir)
	return dir if subdirs.Length == 0 or subdirs.Length > 1
	version as Version
	return subdirs[0] if version.TryParse(Path.GetFileName(subdirs[0]), version)
	return dir

def Save(paths as string, path as string, filename as string):
	serializer = XmlSerializer(Project)
	using stream = File.OpenRead(filename):
		libProperties = cast(Project, serializer.Deserialize(stream))
	libProperties.PropertyGroup.LibPath = path
	libProperties.PropertyGroup.PackagePath = path
	libProperties.PropertyGroup.ReferencePath = paths
	using stream = File.OpenWrite(filename):
		serializer.Serialize(stream, libProperties)

desc """
Устанавливает библиотеку, пример bake lib name=NUnit
"""
task @lib:
	lib = Configuration.name
	installed = ReadInstalled()
	InstallLib(lib, installed)
	paths = installed.Select({l| l.Replace("/", "\\")})
	BuildLibProperties("LibPath", "src/Lib.properties", "..\\..\\..\\lib", paths)
	BuildLibProperties("LibPath", "src/ProjectLib.properties", "..\\..\\lib", paths)
	Import()

desc """
импортирует библиотки из packages в файлы проектов
"""
task @packages:
	return unless Exist(@packages)

	packages = Directory.GetDirectories(@packages).Select({d| Path.Combine(d, @lib)}).Where({d| Exist(d)})\
		.Select({d| CheckPlatformSpecificVersion(d)})\
		.Select({d| '$(PackagePath)\\' + d})
	if Exist(@lib):
		libs = Directory.GetDirectories(@lib).Where({d| not Exist(Path.Combine(d, @src))})\
			.Select({d| GetLibPath(d)})\
			.Select({d| '$(LibPath)\\' + d})
		packages = packages.Concat(libs)
	
	paths = String.Join(";", packages.ToArray())

	filename = "src/Lib.properties"
	path = "..\\..\\.."
	Save(paths, path, filename)

	filename = "src/ProjectLib.properties"
	path = "..\\.."
	Save(paths, path, filename)

	filename = "src/SrcLib.properties"
	path = "..\\..\\..\\.."
	Save(paths, path, filename)

	Import()

desc """
Выводит список доступных библиотек
"""
task @list:
	for lib in Directory.GetDirectories(libRoot):
		print Path.GetFileName(lib) unless Path.GetFileName(lib) == ".svn"

desc """
Добавляет библиотеки как сабмодули git, пример bake ImportLib libs=Common.Tools,Common.MySql
"""
task @ImportLibs:
	for lib in Configuration.libs.ToString().Split(char(',')):
		Sh("git submodule add ssh://git.analit.net/var/www/git/${lib} src/${lib}") if not Exist("src/${lib}")

desc """
устанавливает недостающие пакеты
"""
task @InstallPackages:
	Exec("nuget", "install packages.config", BaseDirectory: "packages").Execute()

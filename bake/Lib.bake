import System
import System.IO
import System.Xml.Linq
import System.Diagnostics
import System.Xml.XPath.Extensions
import System.Xml.Serialization from System.XML
import System.Linq.Enumerable from System.Core
import System.Collections.Generic
import NuGet from NuGet.Core
import NuGet.PackageRepositoryExtensions from NuGet.Core

class Hint:
	public static Hints as List of Hint
	public Id as string
	public Version as IVersionSpec
	public Action as string
	public Target as string

	def Apply(package as IPackage, update as IPackage, manager as PackageManager):
		if Id == package.Id and Version.Satisfies(package.Version):
			if Action == "d":
				print "hint hit for $Id $Version uninstall $Target"
				manager.UninstallPackage(Target)
			if Action == "i":
				print "hint hit for $Id $Version install $Target"
				manager.InstallPackage(Target)
			if Action == "x":
				print "hint hit for $Id $Version execute $Target"
				Bash("${Target} ${package.Id} ${package.Version} ${update.Version}")
			if Action == "s":
				print "hint hit for $Id $Version skip"
				return false
		return true

	static def TryParse(line as string):
		parts = line.Split((char(' '), ), StringSplitOptions.RemoveEmptyEntries)
		if parts.Length != 4:
			return null
		return Hint(Id: parts[0], Version: VersionUtility.ParseVersionSpec(parts[1]), Action: parts[2], Target: parts[3])

def CheckHints(package as IPackage, update as IPackage, manager as PackageManager):
	hints = Hint.Hints
	unless hints:
		hints = List[of Hint]()
		Hint.Hints = hints
		hintsfile = GetResource(@nugethints)
		if Exist(hintsfile):
			lines = File.ReadAllLines(hintsfile)
			for line in lines:
				hint = Hint.TryParse(line)
				continue unless hint
				hints.Add(hint)
		print "loaded ${hints.Count} hints"

	for hint in hints:
		return false unless hint.Apply(package, update, manager)
	return true

[XmlRoot(Namespace: "http://schemas.microsoft.com/developer/msbuild/2003")]
class Project:
	property PropertyGroup as PropertyGroup

class PropertyGroup:
	property LibPath as string
	property PackagePath as string
	property ReferencePath as string
	property StylecopPath as string
	property StylecopAddonPath as string
	property DefineConstants as string

class Package:
	property Name as string
	property Version as string
	property Dir as string

	def constructor():
		pass

	def constructor(name as string, version as string):
		Name = name
		Version = version

	def constructor(path as string):
		a = ParseFromPackageName(path).Split(char('/'))
		Name = a[0]
		Version = a[1]
		Dir = path

	override def Equals(obj):
		return false unless obj isa Package
		package = cast(Package, obj)
		return String.Equals(Name, package.Name, StringComparison.InvariantCultureIgnoreCase)\
			and String.Equals(Version, package.Version, StringComparison.InvariantCultureIgnoreCase)

	override def GetHashCode():
		return (Name.ToLower() + Version.ToLower()).GetHashCode()

	override def ToString():
		return "$Name $Version"

	static def ParseFromPackageName(dir as string):
		name = Path.GetFileName(dir)
		match = /(\.\d+){2,4}(-\w+)?$/.Match(name)
		return null unless match.Success
		return /(\.\d+){2,4}(-\w+)?$/.Replace(name, /^\./.Replace(match.Value, "/"))

libRoot = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "../lib/")

def IsValidPath(path as string, libPath as string):
	return true if path.IndexOf("\\packages\\") < 0
	return false if path.IndexOf("LibPath") >= 0
	return Exist(path.Replace('$(PackagePath)', libPath))

def CleanUp(value as string, libPath as string):
	return value unless value
	paths = value.Split(char(';'))
	return String.Join(";", paths.Where({p| IsValidPath(p, libPath)}))

def ReferencePath(prefix as string, libs as string*):
	return String.Join(";", libs.Select({l| '$(' + prefix + ')\\' + l}).ToArray())

def BuildLibProperties(prefix as string, filename as string, libPath as string, paths as string*):
	xmlNamespace = XNamespace.Get("http://schemas.microsoft.com/developer/msbuild/2003")
	if Exist(filename):
		document = XDocument.Load(filename)
		element = document.Descendants().First({e| e.Name.LocalName == @ReferencePath})
		value = CleanUp(element.Value, libPath)
		libs = paths.Where({p| value.IndexOf(p) < 0})
		element.Value = value + ";" + ReferencePath(prefix, libs)

		unless document.Descendants().FirstOrDefault({e| e.Name.LocalName == prefix}):
			propertyGroup = document.Descendants().First({e| e.Name.LocalName == @PropertyGroup})
			propertyGroup.AddFirst(XElement(xmlNamespace + prefix, libPath))

		document.Save(filename)
	else:
		document = XDocument(XElement(xmlNamespace + @Project,\
			XElement(xmlNamespace + @PropertyGroup,\
				XElement(xmlNamespace + prefix, libPath),\
				XElement(xmlNamespace + @ReferencePath, ReferencePath(prefix, paths)))))
		document.Save(filename)

def Import():
	files = FileSet("src/**/*.*proj").Files.Concat(FileSet("test/**/*.*proj").Files)
	for file in files:
		importPath = "src/ProjectLib.properties"
		candidate1 = CalculateRelativePath(file, importPath)
		if candidate1 == "..\\ProjectLib.properties":
			importPath = candidate1
		else:
			candidate2 = CalculateRelativePath(file, "src/lib.properties")
			if candidate2 == "..\\..\\lib.properties":
				importPath = candidate2
			else:
				raise "Не знаю как импортировать путь к $file $candidate1 $candidate2"

		document = XDocument.Load(file)
		projectNode = document.Elements().First()
		importNode = projectNode.Elements().FirstOrDefault({e| e.Name.LocalName == @Import and\
			e.Attribute(@Project).Value == importPath})
		unless importNode:
			importNode = XElement(projectNode.Name.Namespace + @Import,\
				XAttribute(@Project, importPath),\
				XAttribute(@Condition, "Exists('$importPath')"))
			projectNode.AddFirst(importNode)
			document.Save(file)

def CheckPlatformSpecificVersion(path as string, max as string):
	aliases = {
		"net45" : "net45",
		"net40" : ("net40-full", "net-4.0", "net4", "net40", "NET40ClientProfile"),
		"net20" : ("net35", "20", "2.0", "2", "net20", "net"),
	}

	preferedVersions = List[of string]()
	for alias in aliases:
		if alias.Key == max:
			found = true
		if found:
			preferedVersions.AddRange(alias.Value)

	specificVersion = preferedVersions.Select({v| Path.Combine(path, v)}).FirstOrDefault({d| Directory.Exists(d)})
	if specificVersion:
		return specificVersion
	else:
		return path

def GetLibPath(dir as string):
	subdirs = Directory.GetDirectories(dir)
	return dir if subdirs.Length == 0 or subdirs.Length > 1
	version as Version
	return subdirs[0] if version.TryParse(Path.GetFileName(subdirs[0]), version)
	return dir

def Serialize(filename as string, value):
	Rm(filename) if Exist(filename)
	serializer = XmlSerializer(value.GetType())
	using stream = File.OpenWrite(filename):
		serializer.Serialize(stream, value)

def Save(paths as string, path as string, filename as string, names as (string)):
	project = Project()
	serializer = XmlSerializer(project.GetType())
	project.PropertyGroup = PropertyGroup()
	if Exist(filename):
		#периодически файл оказывается поврежден, студия?
		try:
			using stream = File.OpenRead(filename):
				project = cast(Project, serializer.Deserialize(stream))
		except e:
			Rm(filename)

	project.PropertyGroup.LibPath = path
	project.PropertyGroup.PackagePath = path
	project.PropertyGroup.ReferencePath = paths
	project.PropertyGroup.DefineConstants = String.Join(";", names.Select({n| n.Replace(".", "_").Replace("-", "_")}))

	dir = Directory.GetDirectories(@packages)\
		.Select({d| Path.GetFileName(d)})\
		.FirstOrDefault({d| d.StartsWith("StyleCop.MSBuild.")})
	project.PropertyGroup.StylecopPath = "\$(PackagePath)\\packages\\$dir"
	dir = Directory.GetDirectories(@packages)\
		.Select({d| Path.GetFileName(d)})\
		.FirstOrDefault({d| d.StartsWith("StyleCopAddOn.")})
	project.PropertyGroup.StylecopAddonPath = "\$(PackagePath)\\packages\\$dir"
	Serialize(filename, project)

desc """
импортирует библиотки из packages в файлы проектов
"""
task @packages, ["packages:init", "packages:install"]:
	return unless Exist(@packages)
	Import()

desc """
создает файл конфигурации nuget, вызывается автоматически
"""
task "packages:init":
	if not Exist("src/nuget.config"):
		File.WriteAllText("src/nuget.config", "<settings>\r\n\t<repositoryPath>..\\packages\\</repositoryPath>\r\n</settings>")

def NugetInstall(config as string):
	print config if Configuration.Maybe.debug
	if Exist(config):
		Exec("nuget", "install $config -OutputDirectory packages").Execute()

def GetSlnPackageConfigs():
	return GetProjects().Select({p| Path.Combine(Path.GetDirectoryName(p), "packages.config")})\
		.Where({c| Exist(c)})\
		.ToArray()

def GetPackageConfigs():
	return GetSlnPackageConfigs()\
		.Concat(("packages/packages.config", ))\
		.Where({c| Exist(c)})\
		.ToArray()

def GetInstalledPackages():
	return Directory.GetDirectories(@packages).Select({d| Package(d)}).ToArray()

def GetPackagesForConfig(config as string):
	unless Exist(config):
		return Enumerable.Empty[of Package]().ToArray()
	return XDocument.Load(config).Descendants().Where({n| n.Name == @package})\
		.Select({n| Package(n.Attribute(@id).Value, n.Attribute(@version).Value)}).ToArray()

def GetPackages():
	return GetPackageConfigs().SelectMany({c| GetPackagesForConfig(c)}).ToArray()

desc """
сохраняет все установленные пакеты в packages/packages.config
"""
task "packages:save":
	libPackages = GetSlnPackageConfigs().SelectMany({c| GetPackagesForConfig(c)}).ToArray()
	doc = XDocument()
	root = XElement(@packages)
	doc.Add(root)
	for package in GetInstalledPackages().Except(libPackages):
		packageElement = XElement(@package, XAttribute(@id, package.Name), XAttribute(@version, package.Version))
		root.Add(packageElement)
	doc.Save("packages/packages.config")

desc """
очищает директорию packages от пакетов которые не указаны в packages.config
"""
task "packages:clean":
	packages = GetPackages()
	installedPackages = GetInstalledPackages()
	toDelete = installedPackages.Except(packages)
	for package in toDelete:
		print "remove ${package.Dir}"
		#в директории похоже сидит студия, делаям несколько подходов
		RepeatTry:
			RmDir(package.Dir, true)

desc """
используй packages:install
"""
task @InstallPackages, ["packages:install"]

desc """
устанавливает пакеты описаные в packages.config
параметры:
targetFramework - версия framework под которую будут загружаться библиотеки
если не задана используется Globals.TargetFramework
"""
task "packages:install":
	configs = GetPackageConfigs()
	var nugetPackages = List[of Package]()
	for config in configs:
		NugetInstall(config)
		nugetPackages.AddRange(GetPackagesForConfig(config))
	packagesNames = nugetPackages.Select({p| p.Name}).ToArray()

	packages = Directory.GetDirectories(@packages).Select({d| Path.Combine(d, @lib)}).Where({d| Exist(d)})\
		.Select({d| CheckPlatformSpecificVersion(d, Configuration.Maybe.targetFramework or Globals.TargetFramework)})\
		.Select({d| '$(PackagePath)\\' + d})
	if Exist(@lib):
		packages = packages.Concat(('$(LibPath)\\lib', ))
		libs = Directory.GetDirectories(@lib).Where({d| not Exist(Path.Combine(d, @src))})\
			.Select({d| GetLibPath(d)})\
			.Select({d| '$(LibPath)\\' + d})
		packages = packages.Concat(libs)

	paths = String.Join(";", packages.ToArray())

	filename = "src/Lib.properties"
	path = "..\\..\\.."
	Save(paths, path, filename, packagesNames)

	filename = "src/ProjectLib.properties"
	path = "..\\.."
	Save(paths, path, filename, packagesNames)

	filename = "src/SrcLib.properties"
	path = "..\\..\\..\\.."
	Save(paths, path, filename, packagesNames)

desc """
обновляет пакеты из packages.config
"""
task "packages:update":
	root = Path.GetFullPath("packages")
	fs = PhysicalFileSystem(root)
	settings = Settings.LoadDefaultSettings(fs, null, null)
	source = PackageSource("https://www.nuget.org/api/v2/")
	sources = (source,)
	sourceProvider = PackageSourceProvider(settings, sources)
	factory = PackageRepositoryFactory.Default
	rep = AggregateRepository(factory, sourceProvider.GetEnabledPackageSources().Select({s| s.Source}), true)
	sourceRep = rep

	pathResolver = DefaultPackagePathResolver(fs)
	localRepository = SharedPackageRepository(pathResolver, fs, fs, fs)
	packages = localRepository.GetPackages().ToList()
	packageSorter = PackageSorter(null)
	packages = packageSorter.GetPackagesByDependencyOrder(localRepository).Reverse().ToList()
	c as IPackageConstraintProvider = NullConstraintProvider.Instance
	packageManager = PackageManager(sourceRep, pathResolver, fs, localRepository)
	reffiles = GetSlnPackageConfigs().Select({f| PackageReferenceRepository(PhysicalFileSystem(Path.GetDirectoryName(f)), localRepository)}).ToArray()
	for package in packages:
		print package
		updated as IPackage = PackageRepositoryExtensions.FindPackage(rep, package.Id, null, c, false, false)
		continue unless updated
		continue if package.Version >= updated.Version
		continue unless CheckHints(package, updated, packageManager)
		try:
			packageManager.UpdatePackage(package.Id, true, false)
			for reffile in reffiles:
				if reffile.Exists(package.Id, package.Version):
					reffile.RemovePackage(package)
					reffile.AddPackage(updated)

			print "$package => $updated"
		except e as InvalidOperationException:
			print e.Message

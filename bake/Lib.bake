import System
import System.IO
import System.Xml.Linq
import System.Diagnostics
import System.Xml.XPath.Extensions
import System.Xml.Serialization from System.XML
import System.Linq.Enumerable from System.Core
import System.Collections.Generic
import file from Svn.boo

[XmlRoot(Namespace: "http://schemas.microsoft.com/developer/msbuild/2003")]
class Project:
	property PropertyGroup as PropertyGroup

class PropertyGroup:
	property LibPath as string
	property PackagePath as string
	property ReferencePath as string
	property StylecopPath as string
	property StylecopAddonPath as string

libRoot = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "../lib/")

def ParseFromPackageName(dir as string):
	name = Path.GetFileName(dir)
	match = /(\.\d+){2,4}(-\w+)?$/.Match(name)
	return null unless match.Success
	return /(\.\d+){2,4}(-\w+)?$/.Replace(name, /^\./.Replace(match.Value, "/"))

def IsValidPath(path as string, libPath as string):
	return true if path.IndexOf("\\packages\\") < 0
	return false if path.IndexOf("LibPath") >= 0
	return Exist(path.Replace('$(PackagePath)', libPath))

def CleanUp(value as string, libPath as string):
	return value unless value
	paths = value.Split(char(';'))
	return String.Join(";", paths.Where({p| IsValidPath(p, libPath)}))

def ReferencePath(prefix as string, libs as string*):
	return String.Join(";", libs.Select({l| '$(' + prefix + ')\\' + l}).ToArray())

def BuildLibProperties(prefix as string, filename as string, libPath as string, paths as string*):
	xmlNamespace = XNamespace.Get("http://schemas.microsoft.com/developer/msbuild/2003")
	if Exist(filename):
		document = XDocument.Load(filename)
		element = document.Descendants().First({e| e.Name.LocalName == @ReferencePath})
		value = CleanUp(element.Value, libPath)
		libs = paths.Where({p| value.IndexOf(p) < 0})
		element.Value = value + ";" + ReferencePath(prefix, libs)

		unless document.Descendants().FirstOrDefault({e| e.Name.LocalName == prefix}):
			propertyGroup = document.Descendants().First({e| e.Name.LocalName == @PropertyGroup})
			propertyGroup.AddFirst(XElement(xmlNamespace + prefix, libPath))

		document.Save(filename)
	else:
		document = XDocument(XElement(xmlNamespace + @Project,\
			XElement(xmlNamespace + @PropertyGroup,\
				XElement(xmlNamespace + prefix, libPath),\
				XElement(xmlNamespace + @ReferencePath, ReferencePath(prefix, paths)))))
		document.Save(filename)

def Import():
	importPath = "..\\ProjectLib.properties"
	for dir in Directory.GetDirectories("src"):
		for file in Directory.GetFiles(dir, "*.*proj"):
			document = XDocument.Load(file)
			projectNode = document.Elements().First()
			importNode = projectNode.Elements().FirstOrDefault({e| e.Name.LocalName == @Import and\
				e.Attribute(@Project).Value == importPath})
			unless importNode:
				importNode = XElement(projectNode.Name.Namespace + @Import,\
					XAttribute(@Project, importPath),\
					XAttribute(@Condition, "Exists('$importPath')"))
				projectNode.AddFirst(importNode)
				document.Save(file)

def CheckPlatformSpecificVersion(path as string):
	preferedVersions = ["net40-full", "net4", "net40", "NET40ClientProfile", "net35", "20", "2.0", "2", "net20", "net"]
	specificVersion = preferedVersions.Select({v| Path.Combine(path, v)}).FirstOrDefault({d| Directory.Exists(d)})
	if specificVersion:
		return specificVersion
	else:
		return path

def GetLibPath(dir as string):
	subdirs = Directory.GetDirectories(dir)
	return dir if subdirs.Length == 0 or subdirs.Length > 1
	version as Version
	return subdirs[0] if version.TryParse(Path.GetFileName(subdirs[0]), version)
	return dir

def Save(paths as string, path as string, filename as string):
	serializer = XmlSerializer(Project)
	libProperties = Project()
	libProperties.PropertyGroup = PropertyGroup()
	if Exist(filename):
		using stream = File.OpenRead(filename):
			libProperties = cast(Project, serializer.Deserialize(stream))

	libProperties.PropertyGroup.LibPath = path
	libProperties.PropertyGroup.PackagePath = path
	libProperties.PropertyGroup.ReferencePath = paths
	dir = Directory.GetDirectories(@packages)\
		.Select({d| Path.GetFileName(d)})\
		.FirstOrDefault({d| d.StartsWith("StyleCop.MSBuild.")})
	libProperties.PropertyGroup.StylecopPath = "\$(PackagePath)\\packages\\$dir"
	dir = Directory.GetDirectories(@packages)\
		.Select({d| Path.GetFileName(d)})\
		.FirstOrDefault({d| d.StartsWith("StyleCopAddOn.")})
	libProperties.PropertyGroup.StylecopAddonPath = "\$(PackagePath)\\packages\\$dir"

	using stream = File.OpenWrite(filename):
		serializer.Serialize(stream, libProperties)

def Serialize(filename as string, value):
	serializer = XmlSerializer(value.GetType())
	using stream = File.OpenWrite(filename):
		serializer.Serialize(stream, value)

desc """
импортирует библиотки из packages в файлы проектов
"""
task @packages, [@InstallPackages]:
	return unless Exist(@packages)

	packages = Directory.GetDirectories(@packages).Select({d| Path.Combine(d, @lib)}).Where({d| Exist(d)})\
		.Select({d| CheckPlatformSpecificVersion(d)})\
		.Select({d| '$(PackagePath)\\' + d})
	if Exist(@lib):
		libs = Directory.GetDirectories(@lib).Where({d| not Exist(Path.Combine(d, @src))})\
			.Select({d| GetLibPath(d)})\
			.Select({d| '$(LibPath)\\' + d})
		packages = packages.Concat(libs)
	
	paths = String.Join(";", packages.ToArray())

	filename = "src/Lib.properties"
	path = "..\\..\\.."
	Save(paths, path, filename)

	filename = "src/ProjectLib.properties"
	path = "..\\.."
	Save(paths, path, filename)

	filename = "src/SrcLib.properties"
	path = "..\\..\\..\\.."
	Save(paths, path, filename)

	doc = XDocument()
	root = XElement(@packages)
	doc.Add(root)
	for id, version in Directory.GetDirectories(@packages).Select({d| ParseFromPackageName(d).Split(char('/'))}):
		packageElement = XElement(@package, XAttribute(@id, id), XAttribute(@version, version))
		root.Add(packageElement)
	doc.Save("packages/packages.config")

	Import()

desc """
Добавляет библиотеки как сабмодули git, пример bake ImportLib libs=Common.Tools,Common.MySql
"""
task @ImportLibs:
	for lib in Configuration.libs.ToString().Split(char(',')):
		Sh("git submodule add ssh://git.analit.net/var/git/${lib} src/${lib}") if not Exist("src/${lib}")

desc """
устанавливает недостающие пакеты
"""
task @InstallPackages:
	if Exist("packages/packages.config"):
		Exec("nuget", "install packages.config", BaseDirectory: "packages").Execute()

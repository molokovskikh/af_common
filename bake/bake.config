import System
import System.IO
import System.Reflection
import System.Collections.Generic
import System.Linq.Enumerable
import Bake.IO.Extensions

class AssemblyLocator:

	static assemblies as Dictionary[of string, Assembly]

	public static DebugLoader as bool
	public static LoadDefault as bool = true

	private static cache as string*

	static def Init():
		assemblies = Dictionary[of string, Assembly]()
		AppDomain.CurrentDomain.AssemblyLoad += CurrentDomain_AssemblyLoad
		AppDomain.CurrentDomain.AssemblyResolve += CurrentDomain_AssemblyResolve

	static def CurrentDomain_AssemblyResolve(sender as object, args as ResolveEventArgs):
		try:
			if DebugLoader:
				print "try to resolve ${args.Name}"
			assembly as Assembly = null
			assemblies.TryGetValue(args.Name, assembly)
			#хак сборки boo встроены в bake по этому ресолвить их не надо
			if args.Name.Contains("Boo."):
				return null

			if  args.Name.Contains("Bake."):
				return Assembly.Load("bake")

			if not assembly:
				name = args.Name
				if name.Contains(","):
					name = name[:name.IndexOf(",")]

				assemblyFile = TryFindAssembly(name)
				if assemblyFile:
					assembly = Assembly.LoadFrom(Path.GetFullPath(assemblyFile))

			if DebugLoader:
				if assembly:
					assemblyFile = assembly.Location unless assemblyFile
				print "resolved ${args.Name} to $assembly $assemblyFile"
			return assembly
		except e:
			print e

	static def ParentDir(file as string):
		return Path.GetFileName(Path.GetDirectoryName(file)).ToLower()

	static def ParentDir(file as string, level as int):
		dir = Path.GetDirectoryName(file)
		for i in range(0, level):
			dir = Path.GetDirectoryName(dir)
		name = Path.GetFileName(dir).ToLower()
		return /\d+\.(\d+\.){0,2}\d+/.Match(name).Value

	#в пакетах nuget могут лежать сборки для разных реализаций clr
	#для silverlight например
	#нужно загружать только совместимые
	static def FilterIncompatible(files as List[of string]):
		compatibleClrs = {"net40": Version(4, 0),
			"net40clientprofile": Version(4, 0),
			"net-4.0": Version(4, 0),
			"net35": Version(3, 5),
			"20": Version(2, 0),
			"2.0": Version(2, 0),
			"net": Version(2, 0),
			"lib": Version(2, 0)}
		return files.Where({f| compatibleClrs.ContainsKey(ParentDir(f))}).ToList()

	static def TryFindAssembly(name as string):
		unless cache:
			libRoot = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "packages"))
			localLibs = FileSet("lib/**/*.dll", Excludes: ["**/bin/**", "**/obj/**"]).Files
			globalLibs = FileSet("$libRoot/**/*.dll").Files
			packages = FilterIncompatible(FileSet("packages/**/*.dll").Files)
			if LoadDefault:
				packages = ("",).ToList()
			cache = packages.Concat(localLibs).Concat(globalLibs).ToArray()

		versionToFile = cache.Where({f| String.Equals(Path.GetFileNameWithoutExtension(f), name, StringComparison.OrdinalIgnoreCase)}).Select({f| KeyValuePair[of Version, string](TryGetVersion(f), f)}).ToList()
		return null unless versionToFile.Count
		version = versionToFile.OrderByDescending({p| p.Key}).First()
		return version.Value

	static def TryGetVersion(file as string):
		posibleVersions = (ParentDir(file), ParentDir(file, 2))
		version as Version
		for posibleVersion in posibleVersions:
			if Version.TryParse(posibleVersion, version):
				return version
		return Version()

	static def CurrentDomain_AssemblyLoad(sender as object, args as AssemblyLoadEventArgs):
		try:
			assembly = args.LoadedAssembly
			if DebugLoader:
				name = assembly.GetName().Name
				unless assembly.IsDynamic:
					name += " " + assembly.Location
				print "loaded $name"
			unless assemblies.ContainsKey(assembly.GetName().Name):
				assemblies.Add(assembly.GetName().Name, assembly)
		except e:
			print e

AssemblyLocator.DebugLoader = Environment.CommandLine.Contains("debug-loader")
AssemblyLocator.LoadDefault = not Environment.CommandLine.Contains("load-project")

AssemblyLocator.Init()

libs = List of string()
if Directory.Exists("lib"):
	libs.Add(Path.GetFullPath("lib"))
	for subDir in Directory.GetDirectories("lib"):
		libs.Add(Path.GetFullPath(subDir))

libRoot = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "packages"))
addDir as Action of string = null
addDir = def (dir as string):
	for dir in Directory.GetDirectories(dir):
		if Directory.GetFiles(dir).Length:
			libs.Add(dir)
		else:
			maxDir as string
			for d in Directory.GetDirectories(dir):
				name = Path.GetFileName(d)
				version = Version(name)
				if not maxDir:
					maxDir = name
				elif Version(maxDir) < version:
					maxDir = name
			continue unless maxDir
			libPath = Path.Combine(dir, maxDir)
			libs.Add(libPath)

addDir(libRoot)
Configuration.LibPaths = libs

Configuration.ScriptPaths.Add(AppDomain.CurrentDomain.BaseDirectory)

Configuration.AutoLoad.Add("Git.bake")
Configuration.AutoLoad.Add("Lib.bake")
Configuration.AutoLoad.Add("Tools.bake")

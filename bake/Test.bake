import System
import System.Net
import System.Globalization
import System.Diagnostics
import System.Collections.Generic
import System.Linq.Enumerable
import System.Xml.Linq
import System.Xml.XPath.Extensions from System.Xml.Linq
import System.IO
import System.Net.Mail
import Mono.Cecil
import file from Config.bake
import file from Tools.boo

class Project:
	_project as string
	_projectFile as string
	_isX86 as bool
	_frameworkVersion as string

	property BuildOutput as string
	property TestOutput as string

	def constructor(projectFile as string, project as string, isX86 as bool, frameworkVersion as string):
		_projectFile = projectFile
		_project = project
		_isX86 = isX86
		_frameworkVersion = frameworkVersion

	def Build():
		return Build(false)

	def Build(grubOutput as bool):
		success = true
		clean = MsBuild(_projectFile,
			Target : "clean",
			Parameters : { "Configuration" : "debug" },
			FrameworkVersion : _frameworkVersion,
			GrubOutput : grubOutput)
		clean.Arguments.Add("/verbosity:minimal")

		build = MsBuild(_projectFile,
			Target : "build",
			Parameters : { "Configuration" : "debug" },
			FrameworkVersion : _frameworkVersion,
			GrubOutput : grubOutput)
		build.Arguments.Add("/verbosity:minimal")
		try:
			clean.Execute()
			build.Execute()
		except e as BuildException:
			success = false
			raise unless e.Message.Contains("Command faild with status")

		BuildOutput = clean.Output.ToString() + "\r\n" + build.Output.ToString()
		return success

	def Test():
		return Test(false)

	def Test(grubOutput as bool):
		assembly = "src/${_project}/bin/debug/${_project}.dll"
		assemblyDefinition = AssemblyDefinition.ReadAssembly(assembly)
		_isX86 = assemblyDefinition.MainModule.Architecture == TargetArchitecture.I386

		nunitPath = """nunit-console.exe"""
		if _isX86:
			nunitPath = """nunit-console-x86.exe"""
		nunit = NUnit(assembly,
			ExecutablePath : nunitPath,
			GrubOutput : grubOutput)

		success = true
		try:
			nunit.Execute()
		except e as BuildException:
			success = false
			raise unless e.Message.Contains("Command faild with status")

		TestOutput = nunit.Output.ToString()
		return success

	def ToString():
		return _project

class TestResults:
	successCount = 0
	failCount = 0
	ignoredCount = 0
	brokenTests = List of XElement()
	outputs = List of string()
	totalTime as TimeSpan

	Body as string:
		get:
			return Message()

	property RealTotalTime as TimeSpan
	property Files = List of string()

	def Parse(filename as string):
		doc = XDocument.Load(filename)

		total as decimal
		for element in doc.XPathSelectElements("//test-suite[@type='Assembly']"):
			if attribute = element.Attribute("time"):
				total += Convert.ToDecimal(attribute.Value, CultureInfo.InvariantCulture)
		totalTime += TimeSpan.FromSeconds(total)

		successCount += doc.XPathSelectElements("//test-case[@result='Success']").Count()
		ignoredCount += doc.XPathSelectElements("//test-case[@result='Ignored']").Count()

		failures = doc.XPathSelectElements("//test-case[@result='Failure']")
		failCount += failures.Count()
		brokenTests.AddRange(failures)
		failures = doc.XPathSelectElements("//test-case[@result='Error']")
		failCount += failures.Count()
		brokenTests.AddRange(failures)

		index = Files.Count() + 1
		resultFile = Path.GetFileNameWithoutExtension(filename) + index.ToString() + Path.GetExtension(filename)
		File.Copy(filename, resultFile, true)
		Files.Add(resultFile)

	def Message():
		totalCount = successCount + failCount + ignoredCount
		message = StringWriter()
		message.WriteLine("Всего тестов ${totalCount} прошли ${successCount} сломаны ${failCount} в игноре ${ignoredCount}")
		message.WriteLine("Общее время запуска тестов по мнению nunit $totalTime на самом деле $RealTotalTime")
		for output in outputs:
			message.WriteLine(output)

		if not failCount:
			message.WriteLine("Все тесты прошли успешно")
		else:
			message.WriteLine("Сломанные тесты:")
			for test in brokenTests:
				name = test.Attribute("name").Value
				reason = test.XPathSelectElement(".//message").Value
				stack = test.XPathSelectElement(".//stack-trace").Value
				message.WriteLine(name.Trim())
				message.WriteLine(reason.Trim())
				if stack:
					message.WriteLine(stack.Trim())
				if reason.Contains("failed in FixtureSetup"):
					if failureNode = test.XPathSelectElement("//parent::failure"):
						reason = failureNode.XPathSelectElement(".//message").Value
						stack = failureNode.XPathSelectElement(".//stack-trace").Value
						message.WriteLine(reason.Trim())
						if stack:
							message.WriteLine(stack.Trim())
				message.WriteLine()
		return message.ToString()

	def Output(output as string):
		outputs.Add(output)

frameworkVersion = Globals.FrameworkVersion

def GetProjects():
	isx86 = Globals.Maybe.platform == "x86" or Globals.Maybe.Platform == "x86"
	projects = List[of Project]()
	dirs = Directory.GetDirectories("src")
	for dir in dirs:
		project = Path.GetFileName(dir).ToLower()
		if project.EndsWith(".tests")\
			or project.EndsWith(".test")\
			or project == "test"\
			or project == "functional"\
			or project == "integration"\
			or project == "unit":
			projects.Add(Project(Path.Combine(dir, project) + ".csproj", project, isx86, frameworkVersion))
	return projects

task @test, [@RunTests]

task @PrepareBuild:
	if Exist("build/version.txt"):
		Engine.Execute("GenerateAssemblyInfo")

task @BuildTests, [@PrepareBuild]:
	projects = GetProjects()
	for project in projects:
		raise "Сборка проекта $project завершилась ошибкой" unless project.Build()

task @TestJs:
	return unless Exist("test") or Exist("tools/phantomjs-1.2.0")

	root = Path.GetFullPath("tools/phantomjs-1.2.0")
	phantom = Path.Combine(root, "phantomjs.exe")
	run = Path.Combine(root, "examples", "run-qunit.js")
	for file in Directory.GetFiles("test", "*.html"):
		Sh("$phantom $run $file")

task @RunTests, [@TestJs, @BuildTests]:
	for project in GetProjects():
		project.Test()

def GetProjectName():
	return Path.GetFileName(Environment.CurrentDirectory)

def NotifyError(result as string):
	project = GetProjectName()
	using message = MailMessage("r.kvasov@analit.net", "dev@analit.net"):
		message.Subject = "Сборка $project"
		message.Body = result
		smtpClient = SmtpClient("box.analit.net")
		smtpClient.Send(message)

def Notify(result as TestResults):
	project = GetProjectName()
	using message = MailMessage("r.kvasov@analit.net", "dev@analit.net"):
		message.Subject = "Сборка $project"
		message.Body = result.Body
		for file in result.Files:
			message.Attachments.Add(Attachment(file))
		smtpClient = SmtpClient("box.analit.net")
		smtpClient.Send(message)

#перед запуском тестов нам нужно собрать проект, тк в проекте могут быть
#boo миграции которые используют классы из проекта
task @TryToBuild, [@PrepareBuild]:
	projectPath = Path.GetFullPath("src/${Globals.Project}")
	projectFile = FileSet("${projectPath}/${Globals.Project}.*proj").Files.First()
	MsBuild(projectFile, "/verbosity:quiet",
			Target: "build",
			FrameworkVersion: Globals.FrameworkVersion).Execute()

task @TryBeforeTest:
	if Engine.Tasks.FirstOrDefault({t| t.Name == @BeforeTest}):
		Engine.Execute(@BeforeTest)

task @integration, [@PrepareBuild, @TryBeforeTest]:
	notInteractive = Configuration.Maybe.notInteractive != null
	try:
		projects = GetProjects()
		result = TestResults()

		ExecuteProcess("git", "status")
		log = ExecuteProcess("git", "show HEAD --stat")
		if log:
			result.Output(log)

		for project in projects:
			unless project.Build(notInteractive):
				NotifyError("Сборка завершилась с ошибкой\r\n" + project.BuildOutput)
				return

		for project in projects:
			begin = DateTime.Now
			project.Test(notInteractive)
			result.RealTotalTime += DateTime.Now - begin
			if Exist("TestResult.xml"):
				result.Parse("TestResult.xml")
				Rm("TestResult.xml")
			else:
				result.Output(project.TestOutput)

		if Exist("test") and Exist("tools/phantomjs-1.2.0"):
			root = Path.GetFullPath("tools/phantomjs-1.2.0")
			phantom = Path.Combine(root, "phantomjs.exe")
			run = Path.Combine(root, "examples", "run-qunit.js")
			for file in Directory.GetFiles("test", "*.html"):
				phantomExec = Exec(phantom, "$run $file", GrubOutput: true)
				try:
					phantomExec.Execute()
				except e as BuildException:
					success = false
				result.Output(phantomExec.Output.ToString())

		Notify(result)
	except e as Exception:
		NotifyError(e.ToString())

desc """
запускает сборку проекта на билд сервере
"""
task @integrate:
	url = "http://devsrv.adc.analit.net/god/Projects/Build?id=${Globals.Project}"
	if branch = Configuration.Maybe.branch:
		url += "&ref=$branch"
	request = WebRequest.Create(url)
	request.GetResponse().Dispose()

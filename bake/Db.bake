import System
import System.Linq
import System.Linq.Enumerable
import System.Collections.Generic
import MySql.Data.MySqlClient
import System.Linq.Enumerable from System.Core
import file from Db.boo
import file from LoggingBuilder.boo

def PrintCommand(sql as string):
	print "----------------------------------------"
	print sql
	print "----------------------------------------"

Task @MakePricesActual:
	Db.Execute("""
update PriceItems
set PriceDate = now(),
	LastFormalization = now();
""")

Task @BuildLogTriggers, [@BuildDeleteTrigger, @BuildUpdateTrigger, @BuildInsertTrigger]

Task @SetupLogging, [@CreateLogTable, @BuildLogTriggers]

Desc """
добавляет в таблицу логов отсутствующие колонки и пересоздает триггеры, 
нужна что бы сделать логи актуальными после внесения изменений в таблицу
"""
Task @UpdateLogging, [@UpdateLogTable, @Prepare, @BuildLogTriggers]

task @UpdateLogTable:
	sql = GetUpdateLogTableCommand(Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

#при обновлении логирования, нужно пересоздать триггеры, для этого ставим force
task @Prepare:
	Configuration.Force = true

task @CreateLogTable:
	sql = GetCreateLogTableCommand(Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @BuildInsertTrigger:
	sql = GetLogTriggerCommand("INSERT", Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @BuildUpdateTrigger:
	sql = GetLogTriggerCommand("UPDATE", Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)
	
task @BuildDeleteTrigger:
	sql = GetLogTriggerCommand("DELETE", Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @UpdateSchema:
	Exec("mysql", "--host=localhost --user=root -e\"drop database if exists farm\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"drop database if exists catalogs\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"create database catalogs\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"drop user 'RootDBMS'@'127.0.0.1'\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"create user 'RootDBMS'@'127.0.0.1'\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"grant all on *.* to 'RootDBMS'@'127.0.0.1';\"").Execute()
	Sh("mysqldump --host=testsql.analit.net --user=system --password=newpass catalogs --no-data | mysql --database=catalogs --host=localhost --user=root")

desc """
Дампит таблицу из рабочей базы и сохраняет ее в тестовою
Пример bake Sync Database=Internet Table=ClientEndpoints
"""
Task @Sync:
	Console.Write("user:")
	user = Console.ReadLine()
	Console.Write("password:")
	password = Console.ReadLine()
	Sh("mysqldump -hsql.analit.net -u${user} -p${password} --lock-tables=false --tables ${Configuration.Database} ${Configuration.Table} > dump.txt")
	Sh("mysql -htestsql.analit.net -usystem -pnewpass -D${Configuration.Database} < dump.txt")
	Rm("dump.txt")

desc """
дампит полную схему рабочей базы в файл dump.txt удобно если надо поискать что то в схеме, например использование определенных таблиц в триггерах или процедурах
"""
Task @DumpSchema:
	Console.Write("user:")
	user = Console.ReadLine()
	Console.Write("password:")
	password = Console.ReadLine()
	Sh("mysqldump -hsql2.analit.net -u${user} -p${password} --lock-tables=false --all-databases --events --no-data --routines --triggers > dump.txt")

task @KillBrokenConnections:
	ids = List[of int]()
	for row in Db.Read("show full processlist"):
		id = Convert.ToInt32(row.id)
		state = row.state.ToString()
		time = Convert.ToInt32(row.time)
		if time > 100 and state == "Copying to tmp table":
			ids.Add(id)
			print id
	for id in ids:
		Db.Execute("kill $id")

task @CreateUser:
	user = Configuration.user
	password = "newpass"
	host = "91.209.124.%"
	if Configuration.Maybe.host:
		host = Configuration.host
	privileges = ["Select_priv", "Update_priv", "Insert_priv", "Delete_priv"]
	if Configuration.Maybe.permissions == @programmer:
		privileges = ["Select_priv", "Update_priv", "Insert_priv", "Delete_priv", "Create_priv", "Drop_priv", "Index_priv", "Alter_priv", "Create_tmp_table_priv",
			"Execute_priv", "Create_routine_priv", "Alter_routine_priv", "Trigger_priv"]
	privilegesCommand = String.Join(",", privileges.Cast[of string]().ToArray())
	yCommand = String.Join(",", Enumerable.Repeat("'Y'", privileges.Count))
	Db.Execute("""insert into mysql.user(Host, User, Password, $privilegesCommand)
values ('$host', '$user', password('$password'), $yCommand);
flush privileges;""")
#	if Globals.Environment == @Production:
#		Globals.Environment = @Production2
#		Db.Execute("""insert into mysql.user(Host, User, Password, Select_priv, Update_priv, Insert_priv, Delete_priv)
#values ('$host', '$user', password('$password'), 'Y', 'Y', 'Y', 'Y');
#flush privileges;""")

import System
import System.IO
import System.Linq
import System.Linq.Enumerable
import System.Collections.Generic
import MySql.Data.MySqlClient
import System.Linq.Enumerable from System.Core
import file from Config.bake
import file from Tools.boo
import file from Db.boo
import file from LoggingBuilder.boo

def PrintCommand(sql as string):
	print "----------------------------------------"
	print sql
	print "----------------------------------------"

Task @MakePricesActual:
	Db.Execute("""
update PriceItems
set PriceDate = now(),
	LastFormalization = now();
""")

Task @BuildLogTriggers, [@BuildDeleteTrigger, @BuildUpdateTrigger, @BuildInsertTrigger]

Task @SetupLog, [@CreateLogTable, @BuildLogTriggers]

Desc """
добавляет в таблицу логов отсутствующие колонки и пересоздает триггеры,
нужна что бы сделать логи актуальными после внесения изменений в таблицу
"""
Task @UpdateLog, [@UpdateLogTable, @Prepare, @BuildLogTriggers]

task @UpdateLogTable:
	sql = GetUpdateLogTableCommand(Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

#при обновлении логирования, нужно пересоздать триггеры, для этого ставим force
task @Prepare:
	Configuration.Force = true

task @CreateLogTable:
	sql = GetCreateLogTableCommand(Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @BuildInsertTrigger:
	sql = GetLogTriggerCommand("INSERT", Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @BuildUpdateTrigger:
	sql = GetLogTriggerCommand("UPDATE", Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @BuildDeleteTrigger:
	sql = GetLogTriggerCommand("DELETE", Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @UpdateSchema:
	Exec("mysql", "--host=localhost --user=root -e\"drop database if exists farm\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"drop database if exists catalogs\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"create database catalogs\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"drop user 'RootDBMS'@'127.0.0.1'\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"create user 'RootDBMS'@'127.0.0.1'\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"grant all on *.* to 'RootDBMS'@'127.0.0.1';\"").Execute()
	Sh("mysqldump --host=testsql.analit.net --user=system --password=newpass catalogs --no-data | mysql --database=catalogs --host=localhost --user=root")

task @ReloadLocalDb:
	backupRoot = """C:\backup_data"""
	structure = Path.Combine(backupRoot, "Stuct.sql")
	routne = Path.Combine(backupRoot, "StuctR.sql")
	#Sh("mysqld --standalone")
	#Sh("mysql --host=localhost --user=root -e\"drop user 'RootDBMS'@'127.0.0.1'\"")
	#Sh("mysql --host=localhost --user=root -e\"create user 'RootDBMS'@'127.0.0.1'\"")
	#Sh("mysql --host=localhost --user=root -e\"grant all on *.* to 'RootDBMS'@'127.0.0.1';\"")
	Sh("mysql --host=localhost --user=root < $structure")
	Sh("mysql --host=localhost --user=root < $routne")

desc """
Дампит таблицу из рабочей базы и сохраняет ее в тестовою
Пример bake Sync Database=Internet Table=ClientEndpoints
"""
Task @Sync:
	user = Ask("user:")
	password = AskPassword("password:")
	Sh("mysqldump -hsql.analit.net -u${user} -p${password} --lock-tables=false --tables ${Configuration.Database} ${Configuration.Table} > dump.txt")
	Sh("mysql -htestsql.analit.net -usystem -pnewpass -D${Configuration.Database} < dump.txt")
	Rm("dump.txt")

desc """
дампит полную схему рабочей базы в файл dump.txt удобно если надо поискать что то в схеме, например использование определенных таблиц в триггерах или процедурах
"""
Task @DumpSchema:
	user = Ask("user:")
	password = AskPassword("password:")
	Sh("mysqldump -hsql2.analit.net -u${user} -p${password} --lock-tables=false --all-databases --events --no-data --routines --triggers > dump.txt")

desc """
заливает в локальную базу данных схему из тестовой и таблицы справочники такие как regions
параметры:
profile - название профиля для загрузки, профиль определяет какие таблицы кроме стандартных
будут загружены
значения - catalogs загружается вся база дынных catalogs
"""
task @PrepareLocal:
	sourceDb = "testsql.analit.net"
	destination = "localhost"
	user = "system"
	password = "newpass"

	excludes = ("mysql", "information_schema", "performance_schema", "test")
	databases = join(Db.Read("show databases").Select({r| r.Database.ToString()}).Where({d| not excludes.Any({e| e == d})}).ToArray())
	Sh("mysqldump -h${sourceDb} -u${user} -p${password} --lock-tables=false --add-drop-database --databases $databases --events --no-data --routines --triggers > dump.txt")
	Sh("mysql -h$destination -uroot < dump.txt")
	unless Db(Globals.Environments[@Local].ToString()).ReadSql("select * from mysql.user where User = 'RootDBMS'").Count():
		sql = "CREATE USER 'RootDBMS'@'127.0.0.1';GRANT ALL PRIVILEGES ON *.* TO 'RootDBMS'@'127.0.0.1';"
		Sh("mysql --execute=\"$sql\" -h$destination -uroot")

	tables = ("logs.SchemaMigrations", "Farm.Regions", "Usersettings.Defaults", "Billing.Recipients",
			"ordersendrules.order_handlers", "accessright.permissions", "Usersettings.UserPermissions",
			"farm.sourcetypes", "farm.pricefmts")
	if Configuration.Maybe.profile == "catalogs":
		profileTables = ("catalogs.assortment", "catalogs.catalog", "catalogs.catalogforms",
			"catalogs.catalognames", "catalogs.descriptions", "catalogs.mnn",
			"catalogs.producerequivalents", "catalogs.producers", "catalogs.productproperties",
			"catalogs.products", "catalogs.properties", "catalogs.propertyvalues")
		tables = tables.Concat(profileTables).ToArray()
	for table in tables:
		#database, table = table.Split(char('.'))
		database, tableName = table.Split(char('.'))
		Sh("mysqldump -h${sourceDb} -u${user} -p${password} --lock-tables=false --tables $database $tableName > dump.txt")
		Sh("mysql -h$destination -uroot -D$database < dump.txt")
		Rm("dump.txt")

def ImportLocalDB(backupDBFolder as string):
	sourceDb = "testsql.analit.net"
	user = "system"
	password = "newpass"

	destination = "localhost"

	raise "Не удалось найти директорию ${backupDBFolder}" if not Directory.Exists(backupDBFolder)

	structFile = Path.Combine(backupDBFolder, "struct.sql")
	structRoutineFile = Path.Combine(backupDBFolder, "structRoutine.sql")

	raise "Не удалось найти файл ${structFile} в директории ${backupDBFolder}" if not File.Exists(structFile)
	raise "Не удалось найти файл ${structRoutineFile} в директории ${backupDBFolder}" if not File.Exists(structRoutineFile)

	files = Directory.GetFiles(backupDBFolder, "*.sql")
	#print "files = ${join(files)}"

	tableFiles = files.Where({f| f.IndexOf("\\table.", StringComparison.OrdinalIgnoreCase) > -1}).ToArray()
	dbFiles = files.Where({f| f.IndexOf("\\db.", StringComparison.OrdinalIgnoreCase) > -1}).ToArray()

	#print "tableFiles = ${join(tableFiles)}"
	#print "dbFiles = ${join(dbFiles)}"

	#Создаем пользователя RootDBMS, если он не существует
	unless Db(Globals.Environments[@Local].ToString()).ReadSql("select * from mysql.user where User = 'RootDBMS'").Count():
		sql = "CREATE USER 'RootDBMS'@'127.0.0.1';GRANT ALL PRIVILEGES ON *.* TO 'RootDBMS'@'127.0.0.1';"
		Sh("mysql --execute=\"$sql\" -h$destination -uroot")

	print "Импортирование схемы БД"
	Sh("mysql -h$destination -uroot < ${structFile}")

	tablesCount = tableFiles.Length
	for i, tableFileName in enumerate(tableFiles):
		prefix, database, tableName = Path.GetFileName(tableFileName).Split(char('.'))
		print "Импортирование таблицы-справочника ${i+1} из ${tablesCount}: ${database}.${tableName}"
		Sh("mysql -h$destination -uroot -D$database < ${tableFileName}")

	dbCount = dbFiles.Length
	for i, dbFileName in enumerate(dbFiles):
		prefix, database = Path.GetFileName(dbFileName).Split(char('.'))
		print "Импортирование базы данных ${i+1} из ${dbCount}: ${database}"
		Sh("mysql -h$destination -uroot < ${dbFileName}")

	print "Импортирование ХП и триггеров"
	Sh("mysql -h$destination -uroot < ${structRoutineFile}")

	return

desc """
заливает в локальную базу данных схему из тестовой и таблицы для работы PrgData.
Не экспоритируются данные из схем: documents, orders, logs, redmine, im, telephony.
данные экспортируются в каталог C:\backupDB. После импорта каталог C:\backupDB удаляется.
параметры:
leaveBackup - если установлен в значение true, то не будет удалять директорию backupDB после импорта
"""
task @PrepareLocalForPrgData:
	sourceDb = "testsql.analit.net"
	user = "system"
	password = "newpass"

	destination = "localhost"

	backupDBFolder = """C:\backupDB"""
	Rm(backupDBFolder, true) if Directory.Exists(backupDBFolder)
	MkDir(backupDBFolder)
	raise "Не удалось создать директорию ${backupDBFolder}" if not Directory.Exists(backupDBFolder)

	leaveBackup = Configuration.Maybe.leaveBackup

	structFile = Path.Combine(backupDBFolder, "struct.sql")
	structRoutineFile = Path.Combine(backupDBFolder, "structRoutine.sql")

	#список db, для которых не экспортируется структура
	excludes = ("mysql", "information_schema", "performance_schema")
	#список db, для которых не будут экспортироваться данные в таблицах
	excludesDataDB = ("documents", "orders", "logs", "redmine", "im", "telephony")

	databases = Db.Read("show databases").Select({r| r.Database.ToString()}).Where({d| not excludes.Any({e| e == d})}).ToArray()
	#print "databases for struct = ${join(databases)}"

	print "Экспорт схемы БД"
	Sh("mysqldump -h${sourceDb} -u${user} -p${password} --lock-tables=false --add-drop-database --databases ${join(databases)} --no-data --create-options  --skip-triggers  --default-character-set=cp1251 --quote-names --allow-keywords > ${structFile}")
	print "Экспорт ХП и триггеров"
	Sh("mysqldump -h${sourceDb} -u${user} -p${password} --lock-tables=false --databases ${join(databases)} --no-data --events  --routines  --triggers  --no-create-db --no-create-info  --default-character-set=cp1251 --quote-names --allow-keywords > ${structRoutineFile}")

	# список таблиц-справочников
	tables = ("logs.SchemaMigrations", "Farm.Regions", "Usersettings.Defaults", "Billing.Recipients",
			"ordersendrules.order_handlers", "accessright.permissions", "Usersettings.UserPermissions",
			"farm.sourcetypes", "farm.pricefmts", "documents.waybill_source_types", "documents.waybill_sources")

	tablesCount = tables.Length
	for i, table in enumerate(tables):
		database, tableName = table.Split(char('.'))
		tableFileName = Path.Combine(backupDBFolder, "table.${table}.sql")
		print "Экспорт таблицы ${i+1} из ${tablesCount}: ${table}"
		Sh("mysqldump -h${sourceDb} -u${user} -p${password} --tables $database $tableName  --lock-tables=false  --default-character-set=cp1251 --quote-names --skip-disable-keys --skip-triggers --skip-add-locks --no-autocommit --extended-insert --no-create-db --no-create-info --allow-keywords  --single-transaction  --order-by-primary --max_allowed_packet=32M > ${tableFileName}")

	#databases = ("accessright", "Billing", "documents")
	databases = databases.Where({d| not excludesDataDB.Any({e| e == d})}).ToArray()
	#print "databases for data = ${join(databases)}"
	ignoreTables = join(tables.Select({t| "--ignore-table=" + t}).ToArray())
	#print "ignoreTables = ${ignoreTables}"

	databasesCount = databases.Length
	for i, database in enumerate(databases):
		databaseFileName = Path.Combine(backupDBFolder, "db.${database}.sql")
		print "Экспорт базы данных ${i+1} из ${databasesCount}: ${database}"
		Sh("mysqldump -h${sourceDb} -u${user} -p${password} --databases ${database} ${ignoreTables}  --lock-tables=false  --default-character-set=cp1251 --quote-names --skip-disable-keys --skip-triggers --skip-add-locks --no-autocommit --extended-insert --no-create-db --no-create-info --allow-keywords  --single-transaction  --order-by-primary --max_allowed_packet=32M > ${databaseFileName}")

	ImportLocalDB(backupDBFolder)

	Rm(backupDBFolder, true) if not leaveBackup

	return

desc """
заливает в локальную базу данных схему и таблицы из каталога C:\backupDB
файлы должны быть подготовлены задачей PrepareLocalForPrgData
"""
task @ImportLocalDBForPrgData:
	ImportLocalDB("""C:\backupDB""")

task @KillBrokenConnections:
	ids = List[of int]()
	for row in Db.Read("show full processlist"):
		id = Convert.ToInt32(row.id)
		state = row.state.ToString()
		time = Convert.ToInt32(row.time)
		if time > 100 and state == "Copying to tmp table":
			ids.Add(id)
			print id
	for id in ids:
		Db.Execute("kill $id")

task @CreateUser:
	user = Configuration.user
	password = "newpass"
	host = "91.209.124.%"
	if Configuration.Maybe.host:
		host = Configuration.host
	privileges = ["Select_priv", "Update_priv", "Insert_priv", "Delete_priv"]
	if Configuration.Maybe.permissions == @programmer:
		privileges = ["Select_priv", "Update_priv", "Insert_priv", "Delete_priv", "Create_priv", "Drop_priv", "Index_priv", "Alter_priv", "Create_tmp_table_priv",
			"Execute_priv", "Create_routine_priv", "Alter_routine_priv", "Trigger_priv"]
	if Configuration.Maybe.permissions == @readonly:
		privileges = ["Select_priv", "Create_tmp_table_priv", "Execute_priv"]
	privilegesCommand = String.Join(",", privileges.Cast[of string]().ToArray())
	yCommand = String.Join(",", Enumerable.Repeat("'Y'", privileges.Count))
	Db.Execute("""insert into mysql.user(Host, User, Password, $privilegesCommand)
values ('$host', '$user', password('$password'), $yCommand);
flush privileges;""")

import System
import System.IO
import System.Linq
import System.Linq.Enumerable
import System.Collections.Generic
import MySql.Data.MySqlClient
import System.Linq.Enumerable from System.Core
import file from Config.bake
import file from Tools.boo
import file from Db.boo
import file from LoggingBuilder.boo

class DbProfile:
	property ImportDbs as (string) = (,)
	property ImportTables as (string) = (,)
	
	def constructor():
		pass
		
	def constructor(profile as DbProfile):
		Tables(profile.ImportTables)
		Dbs(profile.ImportDbs)
	
	def Tables(names as string*):
		ImportTables = ImportTables.Concat(names).ToArray()
	
	def Dbs(names as string*):
		ImportDbs = ImportDbs.Concat(names).ToArray()

def PrintCommand(sql as string):
	print "----------------------------------------"
	print sql
	print "----------------------------------------"

emptyProfile = DbProfile(\
	ImportTables: ("logs.SchemaMigrations", "Farm.Regions", "Usersettings.Defaults", "Billing.Recipients",
		"ordersendrules.order_handlers", "accessright.permissions", "Usersettings.UserPermissions",
		"farm.sourcetypes", "farm.pricefmts", "documents.waybill_source_types",
		"internet.AccessCategories",
		"internet.categoriesaccessset",
		"internet.usercategories",
		"internet.status")
)

catalogProfile = DbProfile(emptyProfile)
catalogProfile.Tables(("catalogs.assortment", "catalogs.catalog", "catalogs.catalogforms",
		"catalogs.catalognames", "catalogs.descriptions", "catalogs.mnn",
		"catalogs.producerequivalents", "catalogs.producers", "catalogs.productproperties",
		"catalogs.products", "catalogs.properties",
		"catalogs.propertyvalues"))

customersProfile = DbProfile(emptyProfile)
customersProfile.Dbs(("accessright", "billing", "catalogs", "contacts", "customers", "ordersendrules", "usersettings"))
customersProfile.Tables(("farm.CostFormRules", "farm.FormRules", "farm.sources", "documents.waybill_sources", "logs.authorizationdates", "documents.certificatesources", "documents.sourcesuppliers"))

reportsProfile = DbProfile(customersProfile)
reportsProfile.Tables(("reports.enum_values", "reports.general_reports", "reports.property_enums", "reports.report_properties", "reports.report_property_values", "reports.report_type_properties", "reports.reports", "reports.reporttypes"))

coreProfile = DbProfile(customersProfile)
coreProfile.Tables(("farm.Core0", "farm.CoreCosts", "farm.Synonym", "farm.SynonymFirmCr"))

InternetProfile = DbProfile(emptyProfile)
InternetProfile.Dbs(("accessright", "analit", "contacts", "internet", "telephony"))
InternetProfile.Tables(("logs.internetsessionslogs", "logs.clientendpointinternetlogs"))

profiles = {@empty: emptyProfile, @customers: customersProfile, @catalog: catalogProfile, @core: coreProfile, @internet: InternetProfile, @reports: reportsProfile}

task @MakePricesActual:
	Db.Execute("""
update PriceItems
set PriceDate = now(),
	LastFormalization = now();
""")

task @BuildLogTriggers, [@BuildDeleteTrigger, @BuildUpdateTrigger, @BuildInsertTrigger]

task @SetupLog, [@CreateLogTable, @BuildLogTriggers]

Desc """
добавляет в таблицу логов отсутствующие колонки и пересоздает триггеры,
нужна что бы сделать логи актуальными после внесения изменений в таблицу
"""
task @UpdateLog, [@UpdateLogTable, @Prepare, @BuildLogTriggers]

task @UpdateLogTable:
	sql = GetUpdateLogTableCommand(Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

#при обновлении логирования, нужно пересоздать триггеры, для этого ставим force
task @Prepare:
	Configuration.Force = true

task @CreateLogTable:
	sql = GetCreateLogTableCommand(Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @BuildInsertTrigger:
	sql = GetLogTriggerCommand("INSERT", Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @BuildUpdateTrigger:
	sql = GetLogTriggerCommand("UPDATE", Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @BuildDeleteTrigger:
	sql = GetLogTriggerCommand("DELETE", Configuration.Database, Configuration.Table)
	PrintCommand(sql)
	Db.Execute(sql)

task @UpdateSchema:
	Exec("mysql", "--host=localhost --user=root -e\"drop database if exists farm\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"drop database if exists catalogs\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"create database catalogs\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"drop user 'RootDBMS'@'127.0.0.1'\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"create user 'RootDBMS'@'127.0.0.1'\"").Execute()
	Exec("mysql", "--host=localhost --user=root -e\"grant all on *.* to 'RootDBMS'@'127.0.0.1';\"").Execute()
	Sh("mysqldump --host=testsql.analit.net --user=system --password=newpass catalogs --no-data | mysql --database=catalogs --host=localhost --user=root")

task @ReloadLocalDb:
	backupRoot = """C:\backup_data"""
	structure = Path.Combine(backupRoot, "Stuct.sql")
	routne = Path.Combine(backupRoot, "StuctR.sql")
	#Sh("mysqld --standalone")
	#Sh("mysql --host=localhost --user=root -e\"drop user 'RootDBMS'@'127.0.0.1'\"")
	#Sh("mysql --host=localhost --user=root -e\"create user 'RootDBMS'@'127.0.0.1'\"")
	#Sh("mysql --host=localhost --user=root -e\"grant all on *.* to 'RootDBMS'@'127.0.0.1';\"")
	Sh("mysql --host=localhost --user=root < $structure")
	Sh("mysql --host=localhost --user=root < $routne")

desc """
Дампит таблицу из рабочей базы и сохраняет ее в тестовою
Пример bake Sync Database=Internet Table=ClientEndpoints
"""
Task @Sync:
	user = Ask("user:")
	password = AskPassword("password:")
	Sh("mysqldump -hsql.analit.net -u${user} -p${password} --lock-tables=false --tables ${Configuration.Database} ${Configuration.Table} > dump.txt")
	Sh("mysql -htestsql.analit.net -usystem -pnewpass -D${Configuration.Database} < dump.txt")
	Rm("dump.txt")

desc """
дампит полную схему рабочей базы в файл dump.txt удобно если надо поискать что то в схеме, например использование определенных таблиц в триггерах или процедурах
"""
Task @DumpSchema:
	user = Ask("user:")
	password = AskPassword("password:")
	host = Ask("host:")
	Sh("mysqldump -h$host -u$user -p$password --lock-tables=false --all-databases --events --no-data --routines --triggers > dump.txt")

def ImportSchema(mysqldump as string, mysql as string):
	excludes = ("mysql", "information_schema", "performance_schema", "test")
	db = Db(Globals.Environments[@Development].ToString())
	databases = join(db.ReadSql("show databases").Select({r| r.Database.ToString()}).Where({d| not excludes.Any({e| e == d})}).ToArray())
	Sh("$mysqldump --add-drop-database --databases $databases --events --no-data --routines --triggers > dump.txt")
	Sh("$mysql < dump.txt")

def ImportDatabases(mysqldump as string, mysql as string, databases as string*):
	return unless databases
	for database in databases:
		Sh("$mysqldump $database > dump.txt")
		Sh("$mysql -D$database < dump.txt")
		Rm("dump.txt")

def ImportTables(mysqldump as string, mysql as string, tables as string*):
	return unless tables
	for table in tables:
		database, tableName = table.Split(char('.'))
		Sh("$mysqldump --tables $database $tableName > dump.txt")
		Sh("$mysql -D$database < dump.txt")
		Rm("dump.txt")

def ReadEnvVariable(name as string, defaultValue):
	return Configuration[name] if Configuration.IsDefined(name)
	return Globals[ToPascal(name)] if Globals.IsDefined(ToPascal(name))
	return defaultValue

desc """
заливает в локальную базу данных схему из тестовой и таблицы справочники такие как regions
параметры:
profile - название профиля для загрузки, профиль определяет какие таблицы кроме стандартных
будут загружены
значения:
empty - только схема и справочные таблицы
catalogs - загружается вся база дынных catalogs
customers - customers, billing, usersettings, catalogs, contacts, ordersendrules и источники из farm и documents
"""
task @PrepareLocal:
	sourceDb = "testsql.analit.net"
	destination = "localhost"
	user = "system"
	password = "newpass"

	mysqldump = "mysqldump -h${sourceDb} -u${user} -p${password} --lock-tables=false"
	mysql = "mysql -h$destination -uroot"
	local = Globals.Environments[@Local].ToString()
	if Environment.MachineName.ToLower() == "devsrv":
		port = Globals.Maybe.Port
		mysql = "$mysql --port=$port" if port
		local += ";port=$port" if port and not local.Contains("port")

	ImportSchema(mysqldump, mysql)
	unless Db(local).ReadSql("select * from mysql.user where User = 'RootDBMS'").Count():
		sql = "flush privileges;CREATE USER 'RootDBMS'@'127.0.0.1';GRANT ALL PRIVILEGES ON *.* TO 'RootDBMS'@'127.0.0.1';"
		Sh("$mysql --execute=\"$sql\"")

	profileName = ReadEnvVariable(@profile, @empty)
	profile = profiles[profileName]

	unless profile:
		all = join(profiles.Keys)
		raise "не знаю что за профиль $profileName, есть $all"

	ImportDatabases(mysqldump, mysql, profile.ImportDbs)
	ImportTables(mysqldump, mysql, profile.ImportTables)

def ImportLocalDB(backupDBFolder as string):
	sourceDb = "testsql.analit.net"
	user = "system"
	password = "newpass"

	destination = "localhost"

	raise "Не удалось найти директорию ${backupDBFolder}" if not Directory.Exists(backupDBFolder)

	structFile = Path.Combine(backupDBFolder, "struct.sql")
	structRoutineFile = Path.Combine(backupDBFolder, "structRoutine.sql")

	raise "Не удалось найти файл ${structFile} в директории ${backupDBFolder}" if not File.Exists(structFile)
	raise "Не удалось найти файл ${structRoutineFile} в директории ${backupDBFolder}" if not File.Exists(structRoutineFile)

	files = Directory.GetFiles(backupDBFolder, "*.sql")
	#print "files = ${join(files)}"

	tableFiles = files.Where({f| f.IndexOf("\\table.", StringComparison.OrdinalIgnoreCase) > -1}).ToArray()
	dbFiles = files.Where({f| f.IndexOf("\\db.", StringComparison.OrdinalIgnoreCase) > -1}).ToArray()

	#print "tableFiles = ${join(tableFiles)}"
	#print "dbFiles = ${join(dbFiles)}"

	print "Импортирование схемы БД"
	Sh("mysql -h$destination -uroot < ${structFile}")

	#Создаем пользователя RootDBMS, если он не существует
	unless Db(Globals.Environments[@Local].ToString()).ReadSql("select * from mysql.user where User = 'RootDBMS'").Count():
		sql = "CREATE USER 'RootDBMS'@'127.0.0.1';GRANT ALL PRIVILEGES ON *.* TO 'RootDBMS'@'127.0.0.1';"
		Sh("mysql --execute=\"$sql\" -h$destination -uroot")

	tablesCount = tableFiles.Length
	for i, tableFileName in enumerate(tableFiles):
		prefix, database, tableName = Path.GetFileName(tableFileName).Split(char('.'))
		print "Импортирование таблицы-справочника ${i+1} из ${tablesCount}: ${database}.${tableName}"
		Sh("mysql -h$destination -uroot -D$database < ${tableFileName}")

	dbCount = dbFiles.Length
	for i, dbFileName in enumerate(dbFiles):
		prefix, database = Path.GetFileName(dbFileName).Split(char('.'))
		print "Импортирование базы данных ${i+1} из ${dbCount}: ${database}"
		Sh("mysql -h$destination -uroot < ${dbFileName}")

	print "Импортирование ХП и триггеров"
	Sh("mysql -h$destination -uroot < ${structRoutineFile}")

	return

desc """
заливает в локальную базу данных схему из тестовой и таблицы для работы PrgData.
Не экспоритируются данные из схем: documents, orders, logs, redmine, im, telephony.
данные экспортируются в каталог C:\backupDB. После импорта каталог C:\backupDB удаляется.
параметры:
leaveBackup - если установлен в значение true, то не будет удалять директорию backupDB после импорта
"""
task @PrepareLocalForPrgData:
	sourceDb = "testsql.analit.net"
	user = "system"
	password = "newpass"

	destination = "localhost"

	backupDBFolder = """C:\backupDB"""
	Rm(backupDBFolder, true) if Directory.Exists(backupDBFolder)
	MkDir(backupDBFolder)
	raise "Не удалось создать директорию ${backupDBFolder}" if not Directory.Exists(backupDBFolder)

	leaveBackup = Configuration.Maybe.leaveBackup

	structFile = Path.Combine(backupDBFolder, "struct.sql")
	structRoutineFile = Path.Combine(backupDBFolder, "structRoutine.sql")

	#список db, для которых не экспортируется структура
	excludes = ("mysql", "information_schema", "performance_schema")
	#список db, для которых не будут экспортироваться данные в таблицах
	excludesDataDB = ("documents", "orders", "logs", "redmine", "im", "telephony", "reports")

	databases = Db(Globals.Environments[@Development].ToString()).Read("show databases").Select({r| r.Database.ToString()}).Where({d| not excludes.Any({e| e == d})}).ToArray()
	#print "databases for struct = ${join(databases)}"

	print "Экспорт схемы БД"
	Sh("mysqldump -h${sourceDb} -u${user} -p${password} --lock-tables=false --add-drop-database --databases ${join(databases)} --no-data --create-options  --skip-triggers  --default-character-set=cp1251 --quote-names --allow-keywords > ${structFile}")
	print "Экспорт ХП и триггеров"
	Sh("mysqldump -h${sourceDb} -u${user} -p${password} --lock-tables=false --databases ${join(databases)} --no-data --events  --routines  --triggers  --no-create-db --no-create-info  --default-character-set=cp1251 --quote-names --allow-keywords > ${structRoutineFile}")

	# список таблиц-справочников
	tables = ("logs.SchemaMigrations", "Farm.Regions", "Usersettings.Defaults", "Billing.Recipients",
			"ordersendrules.order_handlers", "accessright.permissions", "Usersettings.UserPermissions",
			"farm.sourcetypes", "farm.pricefmts", "documents.waybill_source_types", "documents.waybill_sources")

	tablesCount = tables.Length
	for i, table in enumerate(tables):
		database, tableName = table.Split(char('.'))
		tableFileName = Path.Combine(backupDBFolder, "table.${table}.sql")
		print "Экспорт таблицы ${i+1} из ${tablesCount}: ${table}"
		Sh("mysqldump -h${sourceDb} -u${user} -p${password} --tables $database $tableName  --lock-tables=false  --default-character-set=cp1251 --quote-names --skip-disable-keys --skip-triggers --skip-add-locks --no-autocommit --extended-insert --no-create-db --no-create-info --allow-keywords  --single-transaction  --order-by-primary --max_allowed_packet=32M > ${tableFileName}")

	#databases = ("accessright", "Billing", "documents")
	databases = databases.Where({d| not excludesDataDB.Any({e| e == d})}).ToArray()
	#print "databases for data = ${join(databases)}"
	ignoreTables = join(tables.Select({t| "--ignore-table=" + t}).ToArray())
	#print "ignoreTables = ${ignoreTables}"

	databasesCount = databases.Length
	for i, database in enumerate(databases):
		databaseFileName = Path.Combine(backupDBFolder, "db.${database}.sql")
		print "Экспорт базы данных ${i+1} из ${databasesCount}: ${database}"
		Sh("mysqldump -h${sourceDb} -u${user} -p${password} --databases ${database} ${ignoreTables}  --lock-tables=false  --default-character-set=cp1251 --quote-names --skip-disable-keys --skip-triggers --skip-add-locks --no-autocommit --extended-insert --no-create-db --no-create-info --allow-keywords  --single-transaction  --order-by-primary --max_allowed_packet=32M > ${databaseFileName}")

	ImportLocalDB(backupDBFolder)

	Rm(backupDBFolder, true) if not leaveBackup

	return

desc """
заливает в локальную базу данных схему и таблицы из каталога C:\backupDB
файлы должны быть подготовлены задачей PrepareLocalForPrgData
"""
task @ImportLocalDBForPrgData:
	ImportLocalDB("""C:\backupDB""")

task @KillBrokenConnections:
	ids = List[of int]()
	for row in Db.Read("show full processlist"):
		id = Convert.ToInt32(row.id)
		state = row.state.ToString()
		time = Convert.ToInt32(row.time)
		if time > 100 and state == "Copying to tmp table":
			ids.Add(id)
			print id
	for id in ids:
		Db.Execute("kill $id")

task @CreateUser:
	user = Configuration.user
	password = "newpass"
	host = "91.209.124.%"
	if Configuration.Maybe.host:
		host = Configuration.host
	privileges = ["Select_priv", "Update_priv", "Insert_priv", "Delete_priv"]
	if Configuration.Maybe.permissions == @programmer:
		privileges = ["Select_priv", "Update_priv", "Insert_priv", "Delete_priv", "Create_priv", "Drop_priv", "Index_priv", "Alter_priv", "Create_tmp_table_priv",
			"Execute_priv", "Create_routine_priv", "Alter_routine_priv", "Trigger_priv"]
	if Configuration.Maybe.permissions == @readonly:
		privileges = ["Select_priv", "Create_tmp_table_priv", "Execute_priv"]
	privilegesCommand = String.Join(",", privileges.Cast[of string]().ToArray())
	yCommand = String.Join(",", Enumerable.Repeat("'Y'", privileges.Count))
	Db.Execute("""insert into mysql.user(Host, User, Password, $privilegesCommand)
values ('$host', '$user', password('$password'), $yCommand);
flush privileges;""")

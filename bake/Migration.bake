import System
import System.IO
import System.Reflection
import System.Diagnostics
import System.Collections.Generic
import System.Linq.Enumerable from System.Core
import MySql.Data.MySqlClient

import Boo.Lang.PatternMatching
import Boo.Lang.Compiler
import Boo.Lang.Compiler.Pipelines
import Boo.Lang.Compiler.IO

import Bake.Engine.Runner

import NHibernate.Mapping
import NHibernate.AdoNet.Util
import NHibernate.Tool.hbm2ddl
import NHibernate.Dialect.Schema

import Castle.ActiveRecord

import file from Config.bake
import file from Db.boo
import file from ActiveRecord.boo
import file from LoggingBuilder.boo
import file from Svn.boo

class Migration:
	property Version as string
	property MigratedOn as DateTime?
	property Name as string
	property FileName as string

	property Commands = List of string()
	property Rollback = List of string()

	IsEmpty as bool:
		get:
			return Commands.Count == 0

	def Cancel():
		Db.Execute("delete from logs.SchemaMigrations where Version = '$Version'")

	def Save():
		if not Exist("migrations"):
			MkDir("migrations")

		Name = Path.GetFileNameWithoutExtension(FileName)
		FileName = Path.Combine("migrations", FileName)

		using stream = StreamWriter(File.OpenWrite(FileName)):
			for sql in Commands:
				stream.Write(sql)
				stream.WriteLine(";")

		using stream = StreamWriter(File.OpenWrite(GetRollbackFile())):
			for sql in Rollback:
				stream.Write(sql)
				stream.WriteLine(";")

		print "saved to $FileName"

	def GetRollbackFile():
		id = GetId()
		return Path.Combine("migrations", "${id}_rollback.sql")

	def GetId():
		return Path.GetFileNameWithoutExtension(FileName)

	def DoRollback():
		id = GetId()
		filename = GetRollbackFile()
		return unless Exist(filename)
		sql = File.ReadAllText(filename)
		print "Rollback $id"
		print "------------------------------------------------------------"
		print sql
		print "------------------------------------------------------------"
		Db.Execute(sql)
		Db.Execute("delete from logs.SchemaMigrations where Version = '$id'")

	def Print():
		print "Migration $Name"
		print "------------------------------------------------------------"
		for sql in Commands:
			print sql
		print "------------------------------------------------------------"

		if Rollback.Count:
			print "Rollback $Name"
			print "------------------------------------------------------------"
			for sql in Rollback:
				print sql
			print "------------------------------------------------------------"

	override def ToString():
		return Version

activeRecordInitalized = false

def FindAssembly(name as string):
	if Exist("src/${Globals.Project}/bin/$name.dll"):
		return "src/${Globals.Project}/bin/$name.dll"
	elif Exist("src/${Globals.Project}/bin/Debug/$name.dll"):
		return "src/${Globals.Project}/bin/Debug/$name.dll"
	elif Exist("src/${Globals.Project}/bin/Debug/$name.exe"):
		return "src/${Globals.Project}/bin/Debug/$name.exe"
	elif Exist("src/$name/bin/debug/$name.exe"):
		return "src/$name/bin/debug/$name.exe"
	elif Exist("src/$name/bin/debug/$name.dll"):
		return "src/$name/bin/debug/$name.dll"

def GetConfiguration():
	assemblies = List of string()
	if assembly = FindAssembly(Globals.Project):
		assemblies.Add(assembly)

	if not assemblies.Count:
		raise "Can`t find project assembly at path 'src/${Globals.Project}/bin/' or 'src/${Globals.Project}/bin/debug/'." \
			+ " Is ${Globals.Project} correct project name and project live at 'src/${Globals.Project}'?"

	if Globals.Maybe.AdditionalAssemblies:
		for name in Globals.AdditionalAssemblies:
			if assembly = FindAssembly(name):
				assemblies.Add(assembly)

	if Configuration.Maybe.assemblies:
		for name in Configuration.assemblies.Split(char(',')):
			if assembly = FindAssembly(name):
				assemblies.Add(assembly)
			else:
				print "can`t find assembly $name"

	return GetActiveRecordConfiguration(assemblies.ToArray())

def SetupActiveRecord():
	return if activeRecordInitalized
	GetConfiguration()
	activeRecordInitalized = true
	
def ImInProject():
	return Exist("src")

def GetMigratedMigrations():
	migrations = List of Migration()
	for migration in Db.Read("select Version, MigratedOn from logs.SchemaMigrations order by MigratedOn"):
		m = Migration(Version: migration.Version.ToString())
		if not migration.MigratedOn isa DBNull:
			m.MigratedOn = cast(DateTime, migration.MigratedOn)
		migrations.Add(m)
	return migrations

def GetMigrated() as List[of string]:
	migrations = List[of string]()
	for migration in Db.Read("select Version from logs.SchemaMigrations"):
		migrations.Add(migration.Version.ToString())
	return migrations

def PrintMigration(name as string, file as string):
	print "Migration ${name}"
	if not File.ReadAllText(file):
		print "Empty migration"
	else:
		print "------------------------------------------------------------"
		print File.ReadAllText(file)
		print "------------------------------------------------------------"

def FindMigration(migration as string):
	fileName = "${Globals.MigrationsPath}/${migration}.sql"
	fileName = "migrations/${migration}.sql" if not Exist(fileName)
	fileName = "${Globals.MigrationsPath}/${migration}.boo" if not Exist(fileName)
	fileName = "migrations/${migration}.boo" if not Exist(fileName)
	return fileName

def FindMigrations(migration as string):
	files = Directory.GetFiles("migrations", "*$migration*.sql")
	return files.Where({f| not f.EndsWith("_rollback.sql")}).Select({f| Path.GetFileNameWithoutExtension(f)}).ToList()

def FindMigrationsEntity(id as string):
	return FindMigrations(id).Select({f| Migration(FileName:f)}).ToArray()

def Apply(fileName as string):
	begin = DateTime.Now
	migration = Path.GetFileNameWithoutExtension(fileName)
	rows = 0
	match Path.GetExtension(fileName).ToLower():
		case ".boo":
			if ImInProject():
				SetupActiveRecord()

			compiler = BooCompiler()
			compiler.Parameters.Input.Add(FileInput(fileName))
			compiler.Parameters.Pipeline = CompileToMemory()
			#compiler.Parameters.Pipeline.Insert(1, AutoReferenceFilesCompilerStep(AppDomain.CurrentDomain.BaseDirectory, MemoryCache()));
			if ImInProject():
				compiler.Parameters.LibPaths.Add("lib")
				for dir in Directory.GetDirectories("lib/"):
					continue if Path.GetFileName(dir).ToLower() == ".svn"
					compiler.Parameters.LibPaths.Add(dir)
			else:
				for dir in Directory.GetDirectories("../lib/"):
					continue if Path.GetFileName(dir).ToLower() == ".svn"
					compiler.Parameters.LibPaths.Add(dir)

			result = compiler.Run()
			if len(result.Warnings):
				print(result.Warnings.ToString())
			if len(result.Errors):
				print(result.Errors.ToString(true))
				return
			main = result.GeneratedAssembly.EntryPoint
			if ImInProject():
				holder = ActiveRecordMediator.GetSessionFactoryHolder()
				sessionFactory = holder.GetSessionFactory(ActiveRecordBase)
				sessionFactory.Statistics.IsStatisticsEnabled = true;
				using scope = TransactionScope(OnDispose.Rollback):
					main.Invoke(null, (null, ))
					scope.VoteCommit()
				statistics = sessionFactory.Statistics
				print "loaded ${statistics.EntityLoadCount}"
				print "inserted ${statistics.EntityInsertCount} updated ${statistics.EntityUpdateCount} deleted ${statistics.EntityDeleteCount}"
				print "transactions ${statistics.TransactionCount} sessions ${statistics.SessionOpenCount}"
				sessionFactory.Statistics.Clear()
			else:
				main.Invoke(null, (null, ))
		case ".sql":
			sql = File.ReadAllText(fileName)
			if not sql:
				return
			rows = Db.Execute(sql)
	seconds = (DateTime.Now - begin).TotalSeconds
	print "executed in ${seconds}s, ${rows} rows affected" 
	Db.Execute("insert into logs.SchemaMigrations Values('${migration}', now())")

#def GetMark(migration as string):
#	match migration:
#		case /^\d+_/:
#			return 

def ToTimeStamp(m as string):
	chars = m[:m.IndexOf("_")].ToCharArray()
	return Convert.ToUInt64(string(chars))

	
def Migrate(migrations as string*):
	migrated = GetMigrated()
	needToMigrate = migrations.Where({m| migrated.All({mg| mg != m})}).ToList()
	if needToMigrate.Count == 0:
		print "Nothing to migrate"
		return
	needToMigrate = needToMigrate.OrderBy({m as string| ToTimeStamp(m)}).ToList()
	for migration in needToMigrate:
		fileName = FindMigration(migration)
		PrintMigration(migration, fileName)
		Apply(fileName)

def GetMigrationFileName(filename as string) as string:
	extension = Path.GetExtension(filename)
	filename = Path.GetFileNameWithoutExtension(filename)
	if not extension:
		extension = ".sql"
	mark = Convert.ToInt32(DateTime.Now.Subtract(DateTime(2011, 1, 1)).TotalDays)
	countMigrationMark = "00"
	if Exist(@migrations):
		localMigrations = Directory.GetFiles("migrations", "${mark}_*.*")
		countMigrationMark = localMigrations.Where({m| not m.ToLower().EndsWith("_rollback.sql")}).Count().ToString("00")
	return "${mark}_${countMigrationMark}_${filename}${extension}"

def GetMigrationFileNameByRequest() as string:
	Console.Write("enter file name:")
	filename = Console.ReadLine()
	return GetMigrationFileName(filename.Trim())

def Save(filename as string, commands as string*):
	if not filename:
		filename = GetMigrationFileNameByRequest()

	if not Exist("migrations"):
		MkDir("migrations")

	migrationFile = Path.GetFullPath("migrations\\${filename}")
	using stream = StreamWriter(File.OpenWrite(migrationFile)):
		for command in commands:
			stream.Write(command)
			stream.WriteLine(";")

	print "saved to ${migrationFile}"
	return migrationFile

def GetMigrations():
	migrations = List[of string]()
	if ImInProject():
		if Exist("migration.txt"):
			migrations.AddRange(File.ReadAllLines("migrations.txt").Where({l| not String.IsNullOrEmpty(l)}))
		if Exist("migrations"):
			migrations.AddRange(Directory.GetFiles("migrations", "*.sql"))
			migrations.AddRange(Directory.GetFiles("migrations", "*.boo"))
	else:
		migrations.AddRange(Directory.GetFiles(".", "*.sql"))
		migrations.AddRange(Directory.GetFiles(".", "*.boo"))
	migrations = migrations.Select({m| Path.GetFileNameWithoutExtension(m)}).Where({m| not m =~ /_rollback/ and (m =~ /^\d/ or m =~ /^\d_/)}).ToList()
	return migrations

def ProcessMigration(migration as Migration):
	migration.Print()
	if Configuration.Maybe.file:
		migration.FileName = GetMigrationFileName(Configuration.Maybe.file)
	else:
		migration.FileName = GetMigrationFileNameByRequest()

	quiet = false
	if Configuration.Maybe.quiet:
		quiet = Configuration.Maybe.quiet

	if quiet:
		migration.Save()
		return

	Console.Write("what should I do [s]ave migration, [a]ply and save or [e]dit?")
	match Console.ReadLine():
		case "a":
			migration.Save()
			Apply(migration.FileName)
		case "s":
			migration.Save()
		case "e":
			migration.Save()
			Process.Start(Globals.Editor, migration.FileName)
		otherwise:
			return

def StartEditor(fileName as string):
	Process.Start(Globals.Editor, fileName)

task @InitActiveRecord:
	SetupActiveRecord()

task @OnlyInProject:
	raise "Задучу имеет смысл запускать только в проекте" if not ImInProject()
		
#Нужно обновить common т.к. может быть ссылка на миграцию а в локальной копии ее нет
task @UpdateCommon:
	return if ImInProject()
	print "Введите учетные данные для обновления Common"
	startInfo = ProcessStartInfo("git", "pull origin", UseShellExecute : false)
	startInfo.WorkingDirectory = Globals.MigrationsPath
	process = Process.Start(startInfo)
	process.WaitForExit(TimeSpan.FromMinutes(2).TotalMilliseconds)
	if process.ExitCode !=0:
		raise "При обновлении Common возникла ошибка с кодом ${process.ExitCode}"

task @Migrate:#, [@UpdateCommon]:
	migrations as List[of string]
	if Configuration.Maybe.id:
		migrations = FindMigrations(Configuration.id.ToString())
	elif Globals.Environment == @Development or ImInProject():
		migrations = GetMigrations()
	else:
		raise "You must set migration id. Example: 'bake id=12'"
	Migrate(migrations)

task @Waiting:
	migrations = GetMigrations()
	migrated = GetMigrated()
	migrations = migrations.OrderBy({s| ToTimeStamp(s)}).ToList()
	for migration in migrations:
		if Configuration.Maybe.full:
			PrintMigration(migration, FindMigration(migration)) if not migrated.Contains(migration)
		else:
			print migration if not migrated.Contains(migration)
Desc """
создает новую миграцию
"""
task @New:
	if ImInProject():
		MkDir("migrations") if not Exist("migrations")
		filename = GetMigrationFileNameByRequest()
		filename = Path.Combine("migrations", filename) 
		File.WriteAllText(filename, "")
		print "saved to ${filename}"
		StartEditor(filename)
	else:
		SvnTool.Update()
		id = GetMigrations().Where({m|m =~ /^\d+$/}).Select({m| Convert.ToInt32(m)}).DefaultIfEmpty().Max() + 1
		migration = "${id}.sql"
		File.WriteAllText(migration, "")
		SvnTool.Command("add ${migration}")
		SvnTool.Command("commit -m\"Забил местечко\" ${migration}")
		print "migration ${migration}"

desc """
Повторяет миграцию
"""	
task @Repeat, [@Rollback, @Migrate]

desc """
откатывает миграцию с помощью файла отката миграции, пример bake Rollback id=77_01_test
id - может быть как и полным именем миграции так и его частью
"""
task @Rollback:
	id = Configuration.id
	migrations = FindMigrationsEntity(id)
	unless migrations.Length:
		raise "Не могу найти файл отката миграции"
	for migration in migrations:
		migration.DoRollback()

task @CancelLastMigration:
	migration = GetMigratedMigrations().Last()
	migration.Cancel()
	print "canceled $migration"

def HasKey(metadata as ITableMetadata, key as ForeignKey):
	field = typeof(AbstractTableMetadata).GetField("foreignKeys", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy)
	metaKeys = field.GetValue(metadata)
	if not metaKeys:
		return false
	keyColumns = key.ColumnIterator.ToArray()
	for keyMetadata as IForeignKeyMetadata in metaKeys.Values:
		columns = keyMetadata.Columns
		for c in keyMetadata.Columns:
			if columns.Length != keyColumns.Length:
				continue
			match = keyColumns.All({c| columns.Any({mc| mc.Name.ToLower() == c.Name.ToLower()}) })
			if match:
				return true
	return false

	for keyMetadata as IIndexMetadata in metaKeys.Values:
		columns = keyMetadata.Columns
		keyColumns = key.ColumnIterator.ToArray()
		for c in keyMetadata.Columns:
			if columns.Length != keyColumns.Length:
				continue
			match = keyColumns.All({c| columns.Any({mc| mc.Name.ToLower() == c.Name.ToLower()}) })
			if match:
				return true
	return false


desc """
Генерирует миграция на основи разницы между мапингом active record и базы данных, пример bake GenerateMigration
"""
task @GenerateMigration, [@OnlyInProject]:
	configuration = GetConfiguration()
	if not configuration.ClassMappings.Count:
		raise "Can`t find any class mapping, check active record version and assemblies list"
	#если нет этого вызова тогда меппинг будет не полным не будет многих внешних ключей
	configuration.BuildSessionFactory()
	mapping = configuration.BuildMapping()
	dialect = NHibernate.Dialect.Dialect.GetDialect(configuration.Properties)

	formatter = DdlFormatter()
	
	cfgProperties = Dictionary[of string, string](dialect.DefaultProperties)
	for pair in configuration.Properties:
		cfgProperties[pair.Key] = pair.Value
	connectionHelper = ManagedProviderConnectionHelper(cfgProperties)
	connectionHelper.Prepare()
	connection = connectionHelper.Connection

	metadata = DatabaseMetadata(connection, dialect)
	migration = Migration()
	foreignKeyAlter = List[of string]()
	foreignKeyRollback = List[of string]()
	for table in configuration.CreateMappings(dialect).IterateTables:
		if table.SchemaActions == SchemaAction.None:
			continue
		tableMetadata = metadata.GetTableMetadata(table.Name, table.Schema, table.Catalog, table.IsQuoted);
		if tableMetadata:
			sqls = table.SqlAlterStrings(dialect, mapping, tableMetadata, null, null)
			for sql in sqls:
				migration.Commands.Add(sql) if sql

			#for key in table.ForeignKeyIterator:
			#	column = key.Columns.First()
			#	key.Name = "FK_$(key.Table.Name)_$(column.Name)"
			#	unless HasKey(tableMetadata, key):
			#		migration.Commands.Add(key.SqlCreateString(dialect, mapping, null, null));
		else:
			sql = formatter.Format(table.SqlCreateString(dialect, mapping, null, null))
			migration.Commands.Add(sql)
			
			for key in table.ForeignKeyIterator:
				columns = String.Join("_", key.Columns.Select({c| c.Name}).ToArray())
				key.Name = "FK_${table.Schema}_$(key.Table.Name)_$columns"
				foreignKeyAlter.Add(key.SqlCreateString(dialect, mapping, null, null));
				migration.Rollback.Insert(0, "alter table ${table.Schema}.${table.Name} drop foreign key ${key.Name}")

			migration.Rollback.Add("drop table if exists ${table.Schema}.${table.Name}")

	migration.Commands.AddRange(foreignKeyAlter)
	if migration.IsEmpty:
		raise "no changes find"

	ProcessMigration(migration)

Desc """
генерирует миграцю для обновления тригеров и таблицы логирования
Пример bake UpdateLogMigration Table=Catalog Database=Catalogs
"""
task @UpdateLogMigration, [@OnlyInProject]:
	table = Configuration.Table
	database = Configuration.Database

	updateTable = GetUpdateLogTableCommand(database, table)
	deleteTrigger = GetLogTriggerCommand("DELETE", database, table)
	updateTrigger = GetLogTriggerCommand("UPDATE", database, table)
	insertTrigger = GetLogTriggerCommand("INSERT", database, table)
	filename = Path.Combine("migrations",  GetMigrationFileName("${database}${table}UpdateLogging"))
	File.WriteAllLines(filename, (updateTable, deleteTrigger, updateTrigger, insertTrigger))
	PrintMigration(Path.GetFileNameWithoutExtension(filename), filename)

Desc """
генерирует миграцю только для тригеров
Пример bake UpdateLogTriggersMigration Table=Catalog Database=Catalogs
"""
task @UpdateLogTriggersMigration, [@OnlyInProject]:
	table = Configuration.Table
	database = Configuration.Database

	deleteTrigger = GetLogTriggerCommand("DELETE", database, table)
	updateTrigger = GetLogTriggerCommand("UPDATE", database, table)
	insertTrigger = GetLogTriggerCommand("INSERT", database, table)
	filename = Path.Combine("migrations",  GetMigrationFileName("${database}${table}UpdateLoggingTriggers"))
	File.WriteAllLines(filename, (deleteTrigger, updateTrigger, insertTrigger))
	PrintMigration(Path.GetFileNameWithoutExtension(filename), filename)

task @CreateLogMigration, [@OnlyInProject]:
	table = Configuration.Table
	database = Configuration.Database

	updateTable = GetCreateLogTableCommand(database, table)
	deleteTrigger = GetLogTriggerCommand("DELETE", database, table)
	updateTrigger = GetLogTriggerCommand("UPDATE", database, table)
	insertTrigger = GetLogTriggerCommand("INSERT", database, table)
	filename = Path.Combine("migrations", GetMigrationFileName("${database}${table}CreateLogging"))
	File.WriteAllLines(filename, (updateTable, deleteTrigger, updateTrigger, insertTrigger))
	PrintMigration(Path.GetFileNameWithoutExtension(filename), filename)

def AlterRoutnie(type as string, db as string, name as string):
	text = Db.Read("SHOW CREATE $type $db.$name").First()["Create $type"]
	text = text.Replace("$type ", "$type $db.")
	migration = Migration()
	drop = "DROP $type $db.$name"
	migration.Commands.Add(drop)
	migration.Commands.Add(text)
	migration.Rollback.Add(drop)
	migration.Rollback.Add(text)
	ProcessMigration(migration)

desc """
создает миграцию и миграцию отката для безопасного удаления таблицы, она переименуется в
_<таблица> что бы потом когда станет понятно что ничего не сломалось
ее можно было удалить
пример bake SafeDropTable Db=Usersettings Name=Clientsdata
"""
task @SafeDropTable:
	db = Configuration.Db
	name = Configuration.Name
	migration = Migration()
	migration.Commands.Add("rename table $db.$name to $db._$name")
	migration.Rollback.Add("rename table $db._$name to $db.$name")
	ProcessMigration(migration)

desc """
создает миграцию и миграцию отката с текстом указанной хранимой процедуры
пример bake AlterProcedure Db=Future Name=GetPrices
"""
task @AlterProcedure:
	db = Configuration.Db
	name = Configuration.Name
	type = "PROCEDURE"
	AlterRoutnie(type, db, name)

desc """
создает миграцию и миграцию отката с текстом указанной хранимой процедуры
пример bake AlterFunction Db=Future Name=GetPrices
"""
task @AlterFunction:
	db = Configuration.Db
	name = Configuration.Name
	type = "FUNCTION"
	AlterRoutnie(type, db, name)

desc """
создает миграцию и миграцию отката с текстом указанной хранимой процедуры
пример bake AlterEvent Db=Future Name=GetPrices
"""
task @AlterEvent:
	db = Configuration.Db
	name = Configuration.Name
	type = "EVENT"
	AlterRoutnie(type, db, name)

desc """
создает миграцию и миграцию отката с текстом указанного триггера
пример bake AlterTrigger Db=Future Name=IntersectionAfterInsert
"""
task @AlterTrigger:
	db = Configuration.Db
	trigger = Configuration.Name
	text = Db.Read("show create trigger $db.$trigger").First()["SQL Original Statement"]
	text = text.Replace("TRIGGER $trigger", "TRIGGER $db.$trigger")
	drop = "drop trigger $db.$trigger"
	migration = Migration()
	migration.Commands.Add(drop)
	migration.Commands.Add(text)
	migration.Rollback.Add(drop)
	migration.Rollback.Add(text)
	ProcessMigration(migration)

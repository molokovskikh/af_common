import System
import System.IO
import System.Diagnostics
import System.Xml.Linq
import System.Xml.XPath.Extensions
import System.Linq.Enumerable from System.Core
import System.Collections.Generic

def UnderSourceControl(path as string):
	dir = Path.GetDirectoryName(path)
	filename = Path.GetFileName(path)
	return false if not Exist(dir)
	output = ExecuteProcess("git", "ls-files", dir)
	lines = output.Split((char('\n'), ), StringSplitOptions.RemoveEmptyEntries)
	return lines.Any({l| l.ToLower().Trim() == filename.ToLower()})

def GetRevision():
	#если не сделать git status то на devsrv git show HEAD вернет пустоту
	head = ExecuteProcess("git", "status")
	head = ExecuteProcess("git", "show HEAD")
	lines = head.Split(("\n",), StringSplitOptions.RemoveEmptyEntries)
	return lines[0].Trim().Replace("commit ", "")

def GetVersionTags():
	tags = ExecuteProcess("git", "tag").Split((char('\n'), ), StringSplitOptions.RemoveEmptyEntries)
	versions = List[of Version]()
	for tag in tags:
		v as Version
		if Version.TryParse(tag.Replace("v", ""), v):
			versions.Add(v)
	return versions

task "version:bump", ["UpdateRevision"]

task @UpdateRevision:
	output = ExecuteProcess("git", "status")
	if not output.Contains("nothing to commit (working directory clean)"):
		raise "bake deploy можно делать только если все закомичено\r\n" \
			+ "проверь что git status говорит nothing to commit (working directory clean)\r\n" \
			+ "а затем попробуй еше раз"

	output = ExecuteProcess("git", "log -1 --pretty=oneline")
	if output.Contains("Релиз версии") or output.Contains("tag: v"):
		print "Последний коммит был релизом, не буду обновлять номер версии тк похоже что это на повторный деплой"
		return

	versions = GetVersionTags()
	currentVersion = versions.LastOrDefault() or Version(GetVersion())
	revision = currentVersion.Revision
	revision++
	newVersion = Version(currentVersion.Major, currentVersion.Minor, currentVersion.Build, revision)
	Sh("git tag v$newVersion")
	Sh("git push --tags")

task "generate:assembly:info":
	revision = GetRevision()
	hash = revision.Trim()
	versions = GetVersionTags()
	version = versions.LastOrDefault()
	fileVersion = version.ToString() if version
	unless version:
		fileVersion = GetVersion()

		tags = ExecuteProcess("git", "tag").Split((char('\n'), ), StringSplitOptions.RemoveEmptyEntries)
		builds = tags.Where({t| /b\d+/.Match(t).Success})\
			.Select({t| Convert.ToInt32(t.Replace("b", "").Trim())})\
			.OrderBy({t| return t})\
			.ToArray()
		if builds.Length:
			revision = builds.Last().ToString()

		if /\./.Matches(fileVersion).Count == 2:
			fileVersion = "$fileVersion.$revision"

	ignore = (/Common\..+/, /Test\..+/, /.+\.Test/)
	if Globals.Maybe.GenerateAssemblyInfoIgnore:
		ignore = ignore.Concat(Globals.Maybe.GenerateAssemblyInfoIgnore).ToArray()
	for project in GetProjects():
		projectName = Path.GetFileNameWithoutExtension(project)
		continue if ignore.Any({i| i.IsMatch(projectName)})
		projectDir = Path.GetDirectoryName(project)
		assemblyInfo = Path.Combine(projectDir, "Properties", "AssemblyInfo.cs")
		unless UnderSourceControl(assemblyInfo):
			dir = Path.GetDirectoryName(assemblyInfo)
			MkDir(dir) if not Exist(dir)
			File.WriteAllText(assemblyInfo, """using System.Reflection;

[assembly: AssemblyTitle("$projectName")]
[assembly: AssemblyProduct("$projectName")]
[assembly: AssemblyCompany("Инфорум")]
[assembly: AssemblyCopyright("$hash")]
[assembly: AssemblyVersion("$fileVersion")]
[assembly: AssemblyFileVersion("$fileVersion")]
[assembly: AssemblyInformationalVersion("$fileVersion")]
""")
			print "generated ${assemblyInfo}"

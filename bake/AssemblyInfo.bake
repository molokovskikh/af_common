import System
import System.IO
import System.Diagnostics
import System.Xml.Linq
import System.Xml.XPath.Extensions
import System.Linq.Enumerable from System.Core
import System.Collections.Generic
import Mono.Cecil

def UnderSourceControl(path as string):
	dir = Path.GetDirectoryName(path)
	filename = Path.GetFileName(path)
	return false if not Exist(dir)
	output = ExecuteProcess("git", "ls-files", dir)
	lines = output.Split((char('\n'), ), StringSplitOptions.RemoveEmptyEntries)
	return lines.Any({l| l.ToLower().Trim() == filename.ToLower()})

def GetRevision():
	#если не сделать git status то на devsrv git show HEAD вернет пустоту
	head = ExecuteProcess("git", "status")
	head = ExecuteProcess("git", "show HEAD")
	lines = head.Split(("\n",), StringSplitOptions.RemoveEmptyEntries)
	return lines[0].Trim().Replace("commit ", "").Trim()

task @UpdateRevision, ["version:bump"]

desc """
создает новый тег версии увеличиваю существующий на 1
что пропустить skipVersionBump=true
"""
task "version:bump":
	return unless Globals.Environment == @Production
	return if Configuration.Maybe.skipVersionBump

	output = ExecuteProcess("git", "status")
	if not output.Contains("nothing to commit (working directory clean)"):
		raise "bake deploy можно делать только если все закомичено\r\n" \
			+ "проверь что git status говорит nothing to commit (working directory clean)\r\n" \
			+ "а затем попробуй еше раз"

	output = ExecuteProcess("git", "log -1 --decorate --pretty=oneline")
	if output.Contains("Релиз версии") or output.Contains("tag: v"):
		print "Последний коммит был релизом, не буду обновлять номер версии тк похоже что это на повторный деплой"
		return

	currentVersion = GetVersionTags().LastOrDefault() or Version(GetVersion())
	revision = currentVersion.Revision
	if revision == -1:
		revision = 0
	revision++
	newVersion = Version(currentVersion.Major, currentVersion.Minor, currentVersion.Build, revision)
	Sh("git tag v$newVersion")
	Sh("git push --tags")

task "generate:assembly:info":
	hash = GetRevision()
	version = GetVersionTags().LastOrDefault() or Version(GetVersion())
	ignore = (/Common\..+/, /Test\..+/, /.+\.Test/)
	if Globals.Maybe.GenerateAssemblyInfoIgnore:
		ignore = ignore.Concat(Globals.Maybe.GenerateAssemblyInfoIgnore).ToArray()

	for project in GetProjects():
		projectName = Path.GetFileNameWithoutExtension(project)
		continue if ignore.Any({i| i.IsMatch(projectName)})
		projectDir = Path.GetDirectoryName(project)
		assemblyInfo = Path.Combine(projectDir, "Properties", "AssemblyInfo.cs")
		unless UnderSourceControl(assemblyInfo):
			dir = Path.GetDirectoryName(assemblyInfo)
			MkDir(dir) if not Exist(dir)
			File.WriteAllText(assemblyInfo, """using System.Reflection;

[assembly: AssemblyTitle("$projectName")]
[assembly: AssemblyProduct("$projectName")]
[assembly: AssemblyCompany("Инфорум")]
[assembly: AssemblyCopyright("$hash")]
[assembly: AssemblyVersion("$version")]
[assembly: AssemblyFileVersion("$version")]
[assembly: AssemblyInformationalVersion("$version")]
""")
			print "generated ${assemblyInfo}"

task "dump:meta":
	name = Configuration.name
	dll = name
	dll = FileSet("packages/**/$name.dll").FirstOrDefault() unless Exist(dll)
	assembly = AssemblyDefinition.ReadAssembly(dll)
	print assembly.Name
	#module = assembly.MainModule
	#for type in module.Types:
	#	print type
	#	for e in type.Events:
			/*print "\t" + e*/
		/*for f in type.Fields:*/
			/*print "\t" + f*/
		/*for p in type.Properties:*/
			/*print "\t" + p*/
		/*for m in type.Methods:*/
			/*print "\t" + m*/

import System
import System.Diagnostics
import System.IO
import System.Text
import System.Net
import System.Net.Mail
import System.Xml.Linq
import System.Xml.XPath.Extensions
import System.Linq.Enumerable from System.Core
import System.Globalization
import file from Config.bake
import System.Text.RegularExpressions
import file from Db.boo

class JenkinsStatus:
	property Number as string
	property Status as string

	def constructor(element as XElement):
		Number = cast(string, element.XPathSelectElement("number"))
		Status = cast(string, element.XPathSelectElement("result"))

class GitStatus:
	public Branch as string
	public ChangesExists as bool
	public NeedPush as bool
	
	def constructor(status as string):
		status = status.Trim()
		ChangesExists = status.IndexOf("nothing to commit", StringComparison.OrdinalIgnoreCase) < 1
		NeedPush = status.IndexOf("Your branch is ahead of", StringComparison.OrdinalIgnoreCase) > 0
		branchString = "# On branch "
		branchStringLen = branchString.Length
		if status.StartsWith(branchString, StringComparison.OrdinalIgnoreCase):
			nextSeparator = status.IndexOfAny(" \r\n".ToCharArray(), branchStringLen)
			Branch = status.Substring(branchStringLen, nextSeparator - branchStringLen + 1).Trim() if nextSeparator > 0

	def IsBranchMaster() as bool:
		return Branch.Equals("master", StringComparison.OrdinalIgnoreCase)

	override def ToString() as string:
		return "Branch: ${Branch};  ChangesExists: ${ChangesExists};  NeedPush: ${NeedPush}"

def GetDeployTo(project as string):
	deployTo = Path.Combine(Globals.DeployRoot, project)

	if Globals.Maybe.DeployAlias:
		deployTo = Path.Combine(Globals.DeployRoot, Globals.DeployAlias)

	if Globals.Maybe.deployTo:
		deployTo = Globals.deployTo

	if Globals.Maybe.DeployTo:
		deployTo = Globals.DeployTo

	if not deployTo:
		raise """Не знаю куда разворачивать проект нужно задать либо Globals.DeployTo = '<путь куда выкладывать>' 
	либо название проекта Globals.Project тогда он будет выложен на Globals.DeployRoot по умолчанию это \\acdcserv.adc.analit.net\WebApps\"""
	return deployTo

if Environment.UserName != "kvasov":
        Globals.Editor = "notepad"
editor = Globals.Editor
humanReadableName = ""
if Globals.IsDefined(@humanReadableName):
	humanReadableName = Globals.humanReadableName
else:
	humanReadableName = Globals.HumanReadableName

project = ""
if Globals.IsDefined("Project"):
	project = Globals.Project
else:
	project = Globals.project

buildTo = Path.GetFullPath(Path.Combine(Globals.BuildRoot.ToString(), project))
deployTo = GetDeployTo(project)

def WriteMessages(file as string, message as string):
	reader = StringReader(message)
	using fileWriter = StreamWriter(file):
		fileWriter.WriteLine()
		fileWriter.WriteLine("# Напиши сообщение которое будет отправленно в рассылку.")
		fileWriter.WriteLine("# Строки помеченые знаком '#' будут игнорироваться.")
		fileWriter.WriteLine("#")
		while (line = reader.ReadLine()) != null:
			fileWriter.WriteLine("# " + line);


def DetectScm():
	return "git" if Exist(".git")
	print "Can not detect scm"
	return ""

def StartEditor(editor as string, message as string):
	try:
		tempFile = Path.GetTempFileName()
		WriteMessages(tempFile, message)
		process = Process.Start(editor, tempFile)
		process.WaitForExit()
		messages = List[of string]()
		using reader = StreamReader(tempFile):
			while (line = reader.ReadLine()) != null:
				if line.Trim() and line.Trim()[0] == char('#'):
					continue
				messages.Add(line)
		return String.Join("\r\n", messages.ToArray())
	ensure:
		Rm(tempFile)

def GetGitDir(command as string, workDir as string):
	output = ""
	error = ""
	startInfo = ProcessStartInfo("git", command,
		RedirectStandardOutput : true,
		RedirectStandardError: true,
		RedirectStandardInput: true,
		StandardOutputEncoding  : Encoding.UTF8,
		CreateNoWindow : true,
		UseShellExecute : false,
		WorkingDirectory: workDir)
	process = Process.Start(startInfo)
	process.OutputDataReceived += do(s, a):
		output += "\r\n" + a.Data
	process.ErrorDataReceived += do(s, a):
		error += "\r\n" + a.Data
	process.BeginOutputReadLine()
	process.BeginErrorReadLine()
	process.WaitForExit()
	if process.ExitCode and error.Trim():
		raise error
	return output

def GetGit(command as string):
	return GetGitDir(command, null)

def GetLastMessagesFromGit():
	return GetGit("log -50")

def GetLastScmMessages():
	scm = DetectScm()
	if scm == "git":
		return GetLastMessagesFromGit()
	return ""

def GetGitStatus():
	return GetGit("status")

def GetGitHead(path as string):
	localHead = GetGitDir("show-ref --head HEAD", path)
	lines = localHead.Trim().Split(char(' '))
	return lines[0].Trim()


backupRoot = """\\offdc\MMedia\AppBackUp\"""

def FindLastBackup():
	directories = Directory.GetDirectories(backupRoot)
	return directories\
		.Where({d| Path.GetFileName(d).StartsWith(project)})\
		.OrderByDescending({d| DateTime.ParseExact(d[d.IndexOf("-") + 1:], "yyyyMMddHHmmss", CultureInfo.CurrentCulture)})\
		.First()

task @SendDeployNotification:
	return if Globals.Environment == @Test

	to = Configuration.Maybe.NotifyTo or "UpdatesList@subscribe.analit.net"

	deployRecord = Db.Read("select GitHash from Logs.Deploys where Project = '$project' order by DeployedOn  desc limit 1").FirstOrDefault()
	if deployRecord:
		lastDeployHash = deployRecord.GitHash
	head = GetGitHead(null)
	if lastDeployHash:
		logs = GetGit("log $lastDeployHash..")
	user = Environment.UserName
	smtp = SmtpClient("box.analit.net")
	Db.Execute("insert into logs.Deploys(User, DeployedOn, GitHash, Project) values('$user', now(), '$head', '$project')")
	jenkinsStatus = ""
	try:
		jenkinsProject = Globals.Maybe.JenkinsProject or project
		uri = "http://devsrv.adc.analit.net:8080/job/$jenkinsProject/api/xml?depth=1"
		doc = XDocument.Load(uri)
		query = "freeStyleProject/build[action/lastBuiltRevision/SHA1[text() = \"$head\"]]"
		elements = doc.XPathSelectElements(query).Select({e| JenkinsStatus(e)}).ToArray()
		if elements.Length:
			element = elements.Where({s| s.Status == "SUCCESS"}).DefaultIfEmpty(elements.First()).First()
			build = element.Number
			result = element.Status
			jenkinsStatus = "Номер сборки $build результат тестирования $result"
		else:
			jenkinsStatus = "Тесты не запускались"
	except e:
		print "не удалось проверить результаты тестов в jenkins"
		print e
	smtp.Send("r.kvasov@analit.net",
		to,
		"Обновление ${humanReadableName}",
		"Релиз подготовил $user\nРевизия $head\n$jenkinsStatus\n$logs")

task @Backup:
	return if Globals.Environment == @Test or Configuration.Maybe.Simulate

	deployTo = GetDeployTo(project)
	backupName = "${project}-${DateTime.Now.ToString('yyyyMMddHHmmss')}"
	backup = Path.Combine(backupRoot, backupName)
	MkDir(backup)
	Cp(FileSet("**/*.*", Excludes : ["*.log", "logs", "request","responce","IdxDir/*.*"], BaseDirectory : deployTo), backup)
	print "backuped to ${backup}"

task @RollbackDeploy, [@WebClean]:
	backup = FindLastBackup()
	Cp(FileSet("**/*.*", Excludes : ["*.log"], BaseDirectory : backup), deployTo)
	backupDate = DateTime.ParseExact(backup[backup.IndexOf("-") + 1:], "yyyyMMddHHmmss", CultureInfo.CurrentCulture)
	print "rollback to $project at $backupDate"
	Rm(backup, true)
	
def GetExcludes():
	excludes = List()
	if Globals.Maybe.ExcludesDeployDirectory:
		for directory in Globals.ExcludesDeployDirectory:
			excludes.Add(directory)
	return excludes
		

task @WebDeploy, [@WebClean]:
	deployTo = GetDeployTo(Globals.Project.ToString())
	buildTo = Path.GetFullPath(Path.Combine(Globals.BuildRoot.ToString(), Globals.Project))
	
	files = FileSet("**/*.*", Excludes : GetExcludes(), BaseDirectory : buildTo)
	if Configuration.Maybe.Simulate:
		print "${files.Files.Count} files deployed to $deployTo"
		return
	Cp(files, deployTo, true)
	print "${files.Files.Count} files deployed to $deployTo"

task @WebClean:
	deployTo = GetDeployTo(Globals.Project.ToString())
	excludes = GetExcludes();
	excludes.Add("*.log")
	Rm(FileSet("**/*.*", Excludes : excludes, BaseDirectory : deployTo))

def CheckRepository(path as string):
	if DetectScm() == "git":
		gitStatus = GitStatus(GetGitDir("status", path))
		raise "В репозитории $path имеются неподтвержденные изменения. Надо произвести Commit и потом выполнить deploy." if gitStatus.ChangesExists
		raise "Текущая ветка ${gitStatus.Branch} репозитория $path не является master-веткой. Надо переключиться в ветку master и потом выполнить deploy." if not gitStatus.IsBranchMaster()
		raise "В текущей ветки есть изменения, не сохраненные в удаленном репозитории. Надо сделать push и потом выполнить deploy." if gitStatus.NeedPush

task @CheckScmChanges, [@CheckCommon, @CheckCurrent]

task @CheckCurrent:
	return if Globals.Environment == @Test

	CheckRepository(Path.GetFullPath("."))

task @CheckCommon:
	return if Globals.Environment == @Test

	path = AppDomain.CurrentDomain.BaseDirectory

	CheckRepository(path)

	localHead = GetGitHead(path)
	remotes = GetGitDir("ls-remote", path)
	remoteHead = /([0-9,a-f]{5,40})\s+HEAD/.Match(remotes).Groups[1].Value
	if remoteHead != localHead:
		raise "Есть обновления скриптов сборки, выполни git pull в $path"

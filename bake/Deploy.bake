import System
import System.Diagnostics
import System.IO
import System.Text
import System.Net
import System.Net.Mail
import System.Xml.Linq
import System.Xml.XPath.Extensions
import System.Linq.Enumerable from System.Core
import System.Globalization
import System.Text.RegularExpressions

class JenkinsStatus:
	property Number as string
	property Status as string

	def constructor(element as XElement):
		Number = cast(string, element.XPathSelectElement("number"))
		Status = cast(string, element.XPathSelectElement("result"))

class GitStatus:
	public Branch as string
	public ChangesExists as bool
	public NeedPush as bool

	def constructor(status as string):
		status = status.Trim()
		ChangesExists = status.IndexOf("nothing to commit", StringComparison.OrdinalIgnoreCase) < 1
		NeedPush = status.IndexOf("Your branch is ahead of", StringComparison.OrdinalIgnoreCase) > 0
		branchString = "# On branch "
		branchStringLen = branchString.Length
		if status.StartsWith(branchString, StringComparison.OrdinalIgnoreCase):
			nextSeparator = status.IndexOfAny(" \r\n".ToCharArray(), branchStringLen)
			Branch = status.Substring(branchStringLen, nextSeparator - branchStringLen + 1).Trim() if nextSeparator > 0

	def IsBranchMaster() as bool:
		return Branch.Equals("master", StringComparison.OrdinalIgnoreCase)

	override def ToString() as string:
		return "Branch: ${Branch};  ChangesExists: ${ChangesExists};  NeedPush: ${NeedPush}"

def GetDeployTo(project as string):
	return GetDeploy(Globals, project)

def DetectScm():
	return "git" if Exist(".git")
	print "Can not detect scm"
	return ""

def GetGitDir(command as string, workDir as string):
	output = ""
	error = ""
	startInfo = ProcessStartInfo("git", command,
		RedirectStandardOutput : true,
		RedirectStandardError: true,
		RedirectStandardInput: true,
		StandardOutputEncoding  : Encoding.UTF8,
		CreateNoWindow : true,
		UseShellExecute : false,
		WorkingDirectory: workDir)
	process = Process.Start(startInfo)
	process.OutputDataReceived += do(s, a):
		output += "\r\n" + a.Data
	process.ErrorDataReceived += do(s, a):
		error += "\r\n" + a.Data
	process.BeginOutputReadLine()
	process.BeginErrorReadLine()
	process.WaitForExit()
	if process.ExitCode and error.Trim():
		raise error
	return output

def GetGit(command as string):
	return GetGitDir(command, null)

def GetLastMessagesFromGit():
	return GetGit("log -50")

def GetLastScmMessages():
	scm = DetectScm()
	if scm == "git":
		return GetLastMessagesFromGit()
	return ""

def GetGitStatus():
	return GetGit("status")

def GetGitHead(path as string):
	localHead = GetGitDir("show-ref --head HEAD", path)
	lines = localHead.Trim().Split(char(' '))
	return lines[0].Trim()

backupRoot = """\\offdc\MMedia\AppBackUp\"""

def FindLastBackup(project as string):
	directories = Directory.GetDirectories(backupRoot)
	return directories\
		.Where({d| Path.GetFileName(d).StartsWith(project)})\
		.OrderByDescending({d| DateTime.ParseExact(d[d.IndexOf("-") + 1:], "yyyyMMddHHmmss", CultureInfo.CurrentCulture)})\
		.First()

unless Engine.Tasks.Any({t| t.Name == "DeployApp"}):
	task @DeployApp, [@WebDeploy]

task "build:stub":
	if Engine.Tasks.Any({t| t.Name == "Build"}):
		Engine.Execute("Build")
	else:
		Engine.Execute("build")

task "deploy:stub":
	if Engine.Tasks.Any({t| t.Name == "deploy:app"}):
		Engine.Execute("deploy:app")
	else:
		Engine.Execute("DeployApp")

task @DeployPipeline, ["deploy:pipeline"]

task "deploy:pipeline", ["packages:install", "check", @Production, "build:stub", @Backup, "db:migrate", "deploy:stub", @SendDeployNotification]

task @WebBuild, [@BuildWebSite]

desc """
отправляет уведомление о развертывание проекта
на UpdatesList@subscribe.analit.net
notifyTo - удрес на который отправлять уведомление вместо стандартного
"""
task @SendDeployNotification:
	return if Globals.Environment == @Test

	project, _, _ = GetBuildConfig(Globals)
	humanReadableName = Globals.Maybe.humanReadableName or Globals.Maybe.HumanReadableName
	to = Configuration.Maybe.notifyTo or "UpdatesList@subscribe.analit.net"

	deployRecord = Db.Read("select GitHash from Logs.Deploys where Project = '$project' order by DeployedOn  desc limit 1").FirstOrDefault()
	if deployRecord:
		lastDeployHash = deployRecord.GitHash
	head = GetGitHead(null)
	if lastDeployHash:
		logs = GetGit("log --no-merges $lastDeployHash..")
	user = Environment.UserName
	smtp = SmtpClient("box.analit.net")
	Db.Execute("insert into logs.Deploys(User, DeployedOn, GitHash, Project) values('$user', now(), '$head', '$project')")
	jenkinsStatus = Globals.Maybe.JenkinsStatus
	smtp.Send("r.kvasov@analit.net",
		to,
		"Обновление ${humanReadableName}",
		"Релиз подготовил $user\nРевизия $head\n$jenkinsStatus\n$logs")

task @Backup:
	return if Globals.Environment == @Test or Configuration.Maybe.Simulate

	project, _, _ = GetBuildConfig(Globals)
	deployTo = GetDeploy(Globals)

	backupName = "${project}-${DateTime.Now.ToString('yyyyMMddHHmmss')}"
	backup = Path.Combine(backupRoot, backupName)
	MkDir(backup)
	Cp(FileSet("**/*.*", Excludes : ["*.log", "logs", "request","responce","IdxDir/*.*"], BaseDirectory : deployTo), backup)
	print "backuped to ${backup}"

task @RollbackDeploy, [@WebClean]:
	project, _, _ = GetBuildConfig(Globals)
	deployTo = GetDeploy(Globals)

	backup = FindLastBackup(project)
	Cp(FileSet("**/*.*", Excludes : ["*.log"], BaseDirectory : backup), deployTo)
	backupDate = DateTime.ParseExact(backup[backup.IndexOf("-") + 1:], "yyyyMMddHHmmss", CultureInfo.CurrentCulture)
	print "rollback to $project at $backupDate"
	Rm(backup, true)

task @WebDeploy, [@WebClean]:
	XCopyDeploy(Globals)

task @CopyTiny:
	deployTo = GetDeployTo(Globals.Project.ToString())
	files = FileSet("**/*.*", Excludes : [], BaseDirectory : "packages/TinyMCE.3.4.5/content/Scripts/")
	Cp(files, deployTo + "/Assets/Javascripts/", true)

task @WebClean:
	deployTo = GetDeployTo(Globals.Project.ToString())
	excludes = GetExcludes(Globals);
	excludes.Add("*.log")
	Rm(FileSet("**/*.*", Excludes : excludes, BaseDirectory : deployTo))

def CheckRepository(path as string):
	if DetectScm() == "git":
		gitStatus = GitStatus(GetGitDir("status", path))
		raise "В репозитории $path имеются неподтвержденные изменения. Надо произвести Commit и потом выполнить deploy." if gitStatus.ChangesExists
		raise "Текущая ветка ${gitStatus.Branch} репозитория $path не является master-веткой. Надо переключиться в ветку master и потом выполнить deploy." if not gitStatus.IsBranchMaster()
		raise "В текущей ветки репозитория $path есть изменения, не сохраненные в удаленном репозитории. Надо сделать push и потом выполнить deploy." if gitStatus.NeedPush

		localHead = GetGitHead(path)
		remotes = GetGitDir("ls-remote", path)
		remoteHead = /([0-9,a-f]{5,40})\s+HEAD/.Match(remotes).Groups[1].Value
		if remoteHead != localHead:
			raise "На удаленном сервере есть изменения которые не загружены в репозиторий $path. "\
				+ "Для того что бы продолжить нужно выполнить git pull и потом повторить bake deploy"

task "check", ["check:common", "check:current", "check:jenkins"]

task @CheckScmChanges, ["check:common", "check:current"]

task "check:current":
	return if Globals.Environment == @Test
	return if Configuration.Maybe.skipCheckCurrent

	CheckRepository(Path.GetFullPath("."))

desc """
проверяет состояние репозитория common
skipCheckCommon=true что бы обойти проверку
"""
task "check:common":
	return if Globals.Environment == @Test
	return if Configuration.Maybe.skipCheckCommon

	CheckRepository(AppDomain.CurrentDomain.BaseDirectory)

desc """
проверяет состояние проекта в jenkins
skipCheckJenkins=true, что бы игнорировать результаты проверки
"""
task "check:jenkins":
	return if Globals.Environment == @Test
	jenkinsProject  = Globals.Maybe.JenkinsProject or Globals.Maybe.Project or Globals.Maybe.project
	url = "http://devsrv.adc.analit.net:8080/job/$jenkinsProject"
	uri = "http://devsrv.adc.analit.net:8080/job/$jenkinsProject/api/xml?depth=1"
	try:
		try:
			doc = XDocument.Load(uri)
		except e:
			message = "Не удалось проверить состояние проекта в jenkins,"\
				+ " проверь что имена проектов совпадают"
			raise Exception(message, e)
		head = GetGitHead(null)
		query = "freeStyleProject/build[action/lastBuiltRevision/SHA1[text() = \"$head\"]]"
		elements = doc.XPathSelectElements(query).Select({e| JenkinsStatus(e)}).ToArray()
		if elements.Length:
			element = elements.Where({s| s.Status == "SUCCESS"}).DefaultIfEmpty(elements.First()).First()
			build = element.Number
			result = element.Status
			Globals.JenkinsStatus = "Номер сборки $build результат тестирования $result"
			if result != "SUCCESS":
				raise "Некоторые тесты сломаны подробней $url,"\
					+ " перед развертыванием следует исправить ошибки"
		else:
			Globals.JenkinsStatus = "Тесты не запускались"
			raise "Тесты для ревизии $head не запускались,"\
				+ " перед развертывание следует прогнать все тесты в jenkins"
	except e:
		message = "Не удалось проверить результаты тестов в jenkins,"\
				+ " skipCheckJenkins=true что бы обойти проверку"
		if Configuration.Maybe.skipCheckJenkins:
			print message
			print e
		else:
			raise Exception(message, e)

import System
import System.Text.RegularExpressions
import System.Resources
import System.Reflection
import System.IO
import System.Net
import System.Diagnostics
import System.Linq.Enumerable
import System.Xml from System.Xml
import System.Xml.Linq
import System.Xml.XPath.Extensions from System.Xml.Linq
import Bake.Win32.Helper
import System.Linq.Enumerable
import Ionic.Zip
import Boo.Lang.Interpreter
import Boo.Lang.Compiler
import Boo.Lang.Compiler.TypeSystem.Reflection
import Mono.Cecil
import Mono.Cecil.Rocks
import Ude

class AssemblyResolver(BaseAssemblyResolver):
	lookup as ILookup[of string, AssemblyDefinition]

	def constructor(cache as ILookup[of string, AssemblyDefinition]):
		lookup = cache

	override def Resolve(name as AssemblyNameReference):
		return lookup[name.Name].FirstOrDefault() or super(name)

desc """
Заменяет TargetFramework во всех проектах на параметер указанный в Version
"""
task @UpdateTargetFramework:
	version = Configuration.Version
	for project in FileSet("src/**.*proj").Files:
		doc = XDocument.Load(project)
		manager = XmlNamespaceManager(NameTable())
		manager.AddNamespace("p", "http://schemas.microsoft.com/developer/msbuild/2003")
		element = doc.XPathSelectElement("//p:TargetFrameworkVersion", manager)
		if element.Value == "v" + version:
			continue
		element.Value = "v" + version
		doc.Save(project)
		print "${project} patched"

def PatchProject(project as string):
	doc = XDocument.Load(project)
	rootNamespace = doc.Root.Name.NamespaceName
	manager = XmlNamespaceManager(NameTable())
	manager.AddNamespace("p", "http://schemas.microsoft.com/developer/msbuild/2003")
	#!BUG doc.XPathSelectElements("//p:Reference", manager):
	#print doc.XPathSelectElement("//p:TargetFrameworkVersion", manager)
	for node in doc.XPathSelectElements("//p:Reference", manager):
		lib = node.Attribute("Include").Value
		lib = lib.Split(char(','))[0]
		libFile = FileSet("lib/**/*.dll").Files.FirstOrDefault()
		continue unless libFile
		libPath = ""# CalculateRelativePath(project, libFile)
		path = node.XPathSelectElement("p:HintPath", manager)
		if not path:
			print "add ${libPath}"
			node.Add(XElement(XName.Get("HintPath", rootNamespace), libPath))
			continue
		else:
			currentLibPath = Path.Combine(Path.GetDirectoryName(project), path.Value)
			if not Exist(currentLibPath):
				print "fixed path from $currentLibPath to $libPath"
				path.Value = libPath
	doc.Save(project)

desc """
Правит путь к библиотекам, почему то иногда библиотеки создаются по не правильным путям
хотя я уверен что буть был верен, может быть resharper косячит, пример bake PatchLibs
"""
task @PatchLibs:
	for dir in Directory.GetDirectories("src"):
		dir = Path.GetFileName(dir)
		project = "src/$dir/$dir.csproj"
		continue if not Exist(project)
		PatchProject(project)

desc """
добавляет в path путь к sdk и .net framework
"""
task @UpdatePath:
	path = Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User)
	sdkPath = MicrosoftSdk.Path()
	frameworkPath = FrameworkInformation.Actual.FullPath
	path = "$path;$sdkPath;$frameworkPath"
	Environment.SetEnvironmentVariable("PATH", path, EnvironmentVariableTarget.User)

desc """
в переменную path текущего пользователя будет добавлена текущая директория
"""
task @pathize:
	path = Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User)
	current = Path.GetFullPath(".")
	path = "$path;$current"
	Environment.SetEnvironmentVariable("PATH", path, EnvironmentVariableTarget.User)

desc """
запускает интерпритатор boo
"""
task @shell:
	CompilerParameters.SharedTypeSystemProvider = ReflectionTypeSystemProvider()
	interpreter = InteractiveInterpreter()
	interpreter.SetValue("bake", Engine)
	console = InteractiveInterpreterConsole(interpreter)
	console.Eval("import Boo.Lang.Interpreter.Builtins")
	Bake.Shell.MakeFuzzi(interpreter, console)
	console.ReadEvalPrintLoop()

desc """
загружает сборку проекта и bake скрипты которые хранятся в папке tasks
"""
task @LoadProject, [@LoadAssemblies]:
	if Exist("tasks"):
		for file in Directory.GetFiles("tasks", "*.bake"):
			using reader = File.OpenText(file):
				try:
					Engine.Loader.Load(file)
				except e:
					print e

task "dump:resource":
	using reader = ResourceReader(Configuration.file.ToString()):
		for i in reader:
			print "${i.Key} = ${i.Value}"

def RemoveStrongName(assembly as AssemblyDefinition):
	module = assembly.MainModule
	assemblyName = assembly.Name

	return false unless assemblyName.HasPublicKey
	assemblyName.HasPublicKey = false
	assemblyName.PublicKey = (of byte:,)
	module.Attributes &= ~ModuleAttributes.StrongNameSigned
	return true

def TryLoad(f as string):
	try:
		return AssemblyDefinition.ReadAssembly(f)
	except:
		return null

def FixWindsor(assembly as AssemblyDefinition):
	attr = assembly.CustomAttributes.FirstOrDefault({a| a.AttributeType.Name == "PreApplicationStartMethodAttribute"})
	if attr:
		assembly.CustomAttributes.Remove(attr)

def GetPatches(assembly as AssemblyDefinition) as (Action[of AssemblyDefinition]):
	if assembly.Name.Name == "Castle.Windsor":
		return (FixWindsor,)
	return (,)

def IsFixInternal(assembly as AssemblyDefinition):
	return assembly.CustomAttributes.Any({a| a.AttributeType.Name == "InternalsVisibleToAttribute"})

desc """
правит ссылки на сборки внутри пакетов приводя их все к одному виду
что не нужно было генерировать binding redirection
которые все равно не работают
тк msbuild проверяет номер версии когда копирует коственные зависимости
парамерты
root - путь к пакетам
Retarget - при установки опции ссылки на сборку System.Core из portable library
правятся на .net 4 это нужно тк .net 4 что бы обойти ошибку в .net
что бы не ставить пакет исправлений KB2468871
"""
task "fix:packages":
	verbose = Configuration.Maybe.verbose
	excludes = ("Xceed.Wpf.Toolkit", "Mono.Cecil", "Mono.Cecil.Mdb", "Mono.Cecil.Pdb", "Mono.Cecil.Rocks",\
		"StyleCop", "StyleCop.CSharp", "StyleCop.CSharp.Rules")
	root = Configuration.Maybe.root or "packages"
	files = FileSet("$root/**/*.dll")
	assemblyNames = files.Select({f| TryLoad(f)}).Where({a| a != null}).ToLookup({a| a.Name.Name})
	for file in files:
		try:
			print "inspect $file" if verbose
			parameters = ReaderParameters()
			parameters.AssemblyResolver = AssemblyResolver(assemblyNames)
			assembly = AssemblyDefinition.ReadAssembly(file, parameters)
			if excludes.Contains(assembly.Name.Name):
				print "skip ${assembly.Name.Name}" if verbose
				continue
			patches = GetPatches(assembly)
			for patch in patches:
				patch(assembly)
			if RemoveStrongName(assembly):
				if IsFixInternal(assembly):
					print "fix internal" if verbose
					attrs = assembly.CustomAttributes.Where({a| a.AttributeType.Name == "InternalsVisibleToAttribute"}).ToArray()
					for attr in attrs:
						arg = attr.ConstructorArguments[0]
						val = arg.Value
						refAssembly = val.Split(char(','))[0]
						if assemblyNames.Contains(refAssembly):
							val = refAssembly
							attr.ConstructorArguments.Remove(arg)
							attr.ConstructorArguments.Add(CustomAttributeArgument(arg.Type, val))
			for reference in assembly.MainModule.AssemblyReferences:
				version as Version
				if assemblyNames.Contains(reference.Name):
					version = assemblyNames[reference.Name].First().Name.Version
				elif Globals.Maybe.Retarget and reference.Name == "System.Core" and reference.Version.ToString() == "2.0.5.0":
					reference.Version = Version(4, 0, 0, 0)
					reference.PublicKeyToken = (of byte: 0xb7, 0x7a, 0x5c, 0x56, 0x19, 0x34, 0xe0, 0x89)
					reference.IsRetargetable = false
				continue unless version
				reference.HasPublicKey = false
				reference.PublicKey = (of byte:,)
				reference.Version = version
				print "fix ref $reference" if verbose
			try:
				assembly.MainModule.ReadSymbols()
			except e:
				pass
			assembly.Write(file, WriterParameters(WriteSymbols: true))
		except e as NotSupportedException:
			if verbose:
				print file
				print e
		except e as AssemblyResolutionException:
			if verbose:
				print file
				print e
		except e as BadImageFormatException:
			if verbose:
				print file
				print e
		except e:
			print file
			print e

task "assembly:remove:strongname":
	name = Configuration.name.ToString()
	assembly = AssemblyDefinition.ReadAssembly(name)
	RemoveStrongName(assembly)
	assembly.Write(name)

task "fix:js:ref":
	ver = "\\d+(\\.\\d+){1,3}"
	packages = Directory.GetDirectories("packages")
	terms = packages.Select({p| Path.GetFileName(p)}).ToArray()
	files = FileSet("packages/**/*.js")
	js = files.Select({f| Path.GetFileName(f)}).Concat(files.Select({f| Path.GetFileNameWithoutExtension(f)})).Where({f| Regex.IsMatch(f, ver)}).ToArray()
	terms = js.Concat(terms).ToArray()
	targets = FileSet("test/*.html").Concat(FileSet("src/**/*.brail").Concat(FileSet("src/**/*.master").Concat(FileSet("src/**/*.aspx")).Concat(FileSet("test/test.js"))))
	if Configuration.Maybe.debug:
		for f in terms:
			print f
		for f in targets:
			print f
	for f in targets:
		encoding = Encoding.UTF8
		using s = File.OpenRead(f):
			s.Position = 0
			detector = CharsetDetector()
			detector.Feed(s)
			detector.DataEnd()
			if detector.Charset:
				encoding = Encoding.GetEncoding(detector.Charset)
		lines = File.ReadAllText(f, encoding)
		write = false
		for term in terms:
			match = Regex(ver).Match(term)
			name = Regex.Escape(term.Substring(0, match.Index))
			name += ver
			name += Regex.Escape(term.Substring(match.Index + match.Length, term.Length - match.Index - match.Length))
			reg = Regex(name, RegexOptions.IgnoreCase)
			result = reg.Replace(lines, term)
			if lines != result:
				lines = result
				write = true
		if write:
			File.WriteAllText(f, lines, Encoding.UTF8)

import System
import System.Reflection
import System.IO
import System.Net
import System.Diagnostics
import System.Linq.Enumerable
import System.Xml from System.Xml
import System.Xml.Linq
import System.Xml.XPath.Extensions from System.Xml.Linq
import Bake.Win32.Helper
import System.Linq.Enumerable
import Ionic.Zip
import Boo.Lang.Interpreter
import Boo.Lang.Compiler
import Boo.Lang.Compiler.TypeSystem.Reflection

desc """
Заменяет TargetFramework во всех проектах на параметер указанный в Version
"""
task @UpdateTargetFramework:
	version = Configuration.Version
	for project in FileSet("src/**.*proj").Files:
		doc = XDocument.Load(project)
		manager = XmlNamespaceManager(NameTable())
		manager.AddNamespace("p", "http://schemas.microsoft.com/developer/msbuild/2003")
		element = doc.XPathSelectElement("//p:TargetFrameworkVersion", manager)
		if element.Value == "v" + version:
			continue
		element.Value = "v" + version
		doc.Save(project)
		print "${project} patched"

task @Production:
	unless Configuration.Maybe.Environment:
		Configuration.Environment = @Production
		Globals.Environment = @Production

#def CalculateRelativePath(fromPath as string, toPath as string):
#	root = GetCommonRoot(fromPath, toPath)
#	#relativeToPath = CalculateRelativePath(root, toPath)
#	depht = GetDepthTo(fromPath, root)
#	for i in range()

def PatchProject(project as string):
	doc = XDocument.Load(project)
	rootNamespace = doc.Root.Name.NamespaceName
	manager = XmlNamespaceManager(NameTable())
	manager.AddNamespace("p", "http://schemas.microsoft.com/developer/msbuild/2003")
	#!BUG doc.XPathSelectElements("//p:Reference", manager):
	#print doc.XPathSelectElement("//p:TargetFrameworkVersion", manager)
	for node in doc.XPathSelectElements("//p:Reference", manager):
		lib = node.Attribute("Include").Value
		lib = lib.Split(char(','))[0]
		libFile = FileSet("lib/**/*.dll").Files.FirstOrDefault()
		continue unless libFile
		libPath = ""# CalculateRelativePath(project, libFile)
		path = node.XPathSelectElement("p:HintPath", manager)
		if not path:
			print "add ${libPath}"
			node.Add(XElement(XName.Get("HintPath", rootNamespace), libPath))
			continue
		else:
			currentLibPath = Path.Combine(Path.GetDirectoryName(project), path.Value)
			if not Exist(currentLibPath):
				print "fixed path from $currentLibPath to $libPath"
				path.Value = libPath
	doc.Save(project)

desc """
Правит путь к библиотекам, почему то иногда библиотеки создаются по не правильным путям
хотя я уверен что буть был верен, может быть resharper косячит, пример bake PatchLibs
"""
task @PatchLibs:
	for dir in Directory.GetDirectories("src"):
		dir = Path.GetFileName(dir)
		project = "src/$dir/$dir.csproj"
		continue if not Exist(project)
		PatchProject(project)

desc """
добавляет в path путь к sdk и .net framework
"""
task @UpdatePath:
	path = Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User)
	sdkPath = MicrosoftSdk.Path()
	frameworkPath = FrameworkInformation.Actual.FullPath
	path = "$path;$sdkPath;$frameworkPath"
	Environment.SetEnvironmentVariable("PATH", path, EnvironmentVariableTarget.User)

desc """
Устанавливает mysql в папку текущего пользователя
"""
task @InstallMySql:
	version = "5.5.12"
	zipFilePath = """C:\apps\"""
	Console.Write("Вы хотите начать скачивание MySql? (132.8Mb) Y/N:")
	return unless Console.ReadLine().ToLower() == "y"
	webClient = WebClient()
#	webClient.DownloadFileCompleted += Completed
#	webClient.DownloadProgressChanged += ProgressChanged
	Console.WriteLine("Скачиваю MySQL")
	downloadFile = Path.GetTempFileName()
	try:
		webClient.DownloadFile(\
			"http://dev.mysql.com/get/Downloads/MySQL-5.5/mysql-$version-win32.zip/from/http://mysql.infocom.ua/",\
			downloadFile)
		Console.WriteLine("Скачивание прошло успешно")

		extractPath = Path.Combine(zipFilePath, "MySQL")
		MkDir(extractPath) unless Exist(extractPath)
		Cp(downloadFile, Path.Combine(extractPath, "mysql-$version-win32.zip"), true)

		using zip = ZipFile.Read(downloadFile):
			mysqlFolderName = Path.GetDirectoryName(zip.Entries.First().FileName).Split(char('\\')).First()
			for e in zip:
				e.Extract(extractPath, ExtractExistingFileAction.OverwriteSilently)
		Console.WriteLine("Файл разархивирован в $extractPath")

		path = Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User)
		path = "" unless path
		unless path.Length > 0 and path.Trim() == ";":
			path += ";"
		binPath = Path.Combine(extractPath, "mysql-$version-win32", "bin")
		path += binPath
		Environment.SetEnvironmentVariable("PATH", path, EnvironmentVariableTarget.User)

		Console.WriteLine("в PATH пользователя добавлен $binPath")
	ensure:
		Rm(downloadFile)

desc """
запускаест visual studion с проектом, примев в корне проета (там где папка src) bake dev
будет запущена студия с этим проектом
"""
task @dev:
	solution = Path.GetFileName(Path.GetFullPath("."))
	Process.Start(Path.GetFullPath("src/$solution.sln"))

desc """
в переменную path текущего пользователя будет добавлена текущая директория
"""
task @pathize:
	path = Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User)
	current = Path.GetFullPath(".")
	path = "$path;$current"
	Environment.SetEnvironmentVariable("PATH", path, EnvironmentVariableTarget.User)

desc """
запускает интерпритатор boo
"""
task @shell:
	CompilerParameters.SharedTypeSystemProvider = ReflectionTypeSystemProvider()
	interpreter = InteractiveInterpreter()
	console = InteractiveInterpreterConsole(interpreter)
	console.Eval("import Boo.Lang.Interpreter.Builtins")
	console.ReadEvalPrintLoop()

desc """
загружает сборку проекта и bake скрипты которые хранятся в папке tasks
"""
task @LoadProject:
	Assembly.LoadFrom("src/${Globals.Project}/bin/${Globals.Project}.dll")
	if Exist("tasks"):
		for file in Directory.GetFiles("tasks", "*.bake"):
			using reader = File.OpenText(file):
				Engine.Loader.Load(reader, file)


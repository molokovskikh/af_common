import System
import System.Resources
import System.Reflection
import System.IO
import System.Net
import System.Diagnostics
import System.Linq.Enumerable
import System.Xml from System.Xml
import System.Xml.Linq
import System.Xml.XPath.Extensions from System.Xml.Linq
import Bake.Win32.Helper
import System.Linq.Enumerable
import Ionic.Zip
import Boo.Lang.Interpreter
import Boo.Lang.Compiler
import Boo.Lang.Compiler.TypeSystem.Reflection
import Mono.Cecil

desc """
Заменяет TargetFramework во всех проектах на параметер указанный в Version
"""
task @UpdateTargetFramework:
	version = Configuration.Version
	for project in FileSet("src/**.*proj").Files:
		doc = XDocument.Load(project)
		manager = XmlNamespaceManager(NameTable())
		manager.AddNamespace("p", "http://schemas.microsoft.com/developer/msbuild/2003")
		element = doc.XPathSelectElement("//p:TargetFrameworkVersion", manager)
		if element.Value == "v" + version:
			continue
		element.Value = "v" + version
		doc.Save(project)
		print "${project} patched"

def PatchProject(project as string):
	doc = XDocument.Load(project)
	rootNamespace = doc.Root.Name.NamespaceName
	manager = XmlNamespaceManager(NameTable())
	manager.AddNamespace("p", "http://schemas.microsoft.com/developer/msbuild/2003")
	#!BUG doc.XPathSelectElements("//p:Reference", manager):
	#print doc.XPathSelectElement("//p:TargetFrameworkVersion", manager)
	for node in doc.XPathSelectElements("//p:Reference", manager):
		lib = node.Attribute("Include").Value
		lib = lib.Split(char(','))[0]
		libFile = FileSet("lib/**/*.dll").Files.FirstOrDefault()
		continue unless libFile
		libPath = ""# CalculateRelativePath(project, libFile)
		path = node.XPathSelectElement("p:HintPath", manager)
		if not path:
			print "add ${libPath}"
			node.Add(XElement(XName.Get("HintPath", rootNamespace), libPath))
			continue
		else:
			currentLibPath = Path.Combine(Path.GetDirectoryName(project), path.Value)
			if not Exist(currentLibPath):
				print "fixed path from $currentLibPath to $libPath"
				path.Value = libPath
	doc.Save(project)

desc """
Правит путь к библиотекам, почему то иногда библиотеки создаются по не правильным путям
хотя я уверен что буть был верен, может быть resharper косячит, пример bake PatchLibs
"""
task @PatchLibs:
	for dir in Directory.GetDirectories("src"):
		dir = Path.GetFileName(dir)
		project = "src/$dir/$dir.csproj"
		continue if not Exist(project)
		PatchProject(project)

desc """
добавляет в path путь к sdk и .net framework
"""
task @UpdatePath:
	path = Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User)
	sdkPath = MicrosoftSdk.Path()
	frameworkPath = FrameworkInformation.Actual.FullPath
	path = "$path;$sdkPath;$frameworkPath"
	Environment.SetEnvironmentVariable("PATH", path, EnvironmentVariableTarget.User)

desc """
в переменную path текущего пользователя будет добавлена текущая директория
"""
task @pathize:
	path = Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User)
	current = Path.GetFullPath(".")
	path = "$path;$current"
	Environment.SetEnvironmentVariable("PATH", path, EnvironmentVariableTarget.User)

desc """
запускает интерпритатор boo
"""
task @shell:
	CompilerParameters.SharedTypeSystemProvider = ReflectionTypeSystemProvider()
	interpreter = InteractiveInterpreter()
	interpreter.SetValue("bake", Engine)
	console = InteractiveInterpreterConsole(interpreter)
	console.Eval("import Boo.Lang.Interpreter.Builtins")
	Bake.Shell.MakeFuzzi(interpreter, console)
	console.ReadEvalPrintLoop()

desc """
загружает сборку проекта и bake скрипты которые хранятся в папке tasks
"""
task @LoadProject, [@LoadAssemblies]:
	if Exist("tasks"):
		for file in Directory.GetFiles("tasks", "*.bake"):
			using reader = File.OpenText(file):
				try:
					Engine.Loader.Load(file)
				except e:
					print e

task "dump:resource":
	using reader = ResourceReader(Configuration.file.ToString()):
		for i in reader:
			print "${i.Key} = ${i.Value}"

def RemoveStrongName(assembly as AssemblyDefinition):
	module = assembly.MainModule
	assemblyName = assembly.Name

	return false unless assemblyName.HasPublicKey
	assemblyName.HasPublicKey = false
	assemblyName.PublicKey = (of byte:,)
	module.Attributes &= ~ModuleAttributes.StrongNameSigned
	return true

def TryLoad(f as string):
	try:
		return AssemblyDefinition.ReadAssembly(f)
	except:
		return null

def PatchInternal(assembly as AssemblyDefinition):
	for t in assembly.MainModule.Types:
		found = false
		for method in t.Methods:
			if method.IsAssembly or method.IsFamilyOrAssembly:
				found = true
				method.IsPublic = true
		for field in t.Fields:
			if field.IsAssembly or field.IsFamilyOrAssembly:
				found = true
				field.IsPublic = true
		if found:
			t.IsPublic = true

desc """
правит ссылки на сборки внутри пакетов приводя их все к одному виду
что не нужно было генерировать binding redirection
которые все равно не работают
тк msbuild проверяет номер версии когда копирует коственные зависимости
"""
task "fix:packages":
	files = FileSet("packages/**/*.dll")
	assemblyNames = files.Select({f| TryLoad(f)}).Where({a| a != null}).ToLookup({a| a.Name.Name})
	for file in files:
		try:
			print "inspect $file"
			assembly = AssemblyDefinition.ReadAssembly(file)
			if RemoveStrongName(assembly):
				if assembly.CustomAttributes.Any({a| a.AttributeType.Name == "InternalsVisibleToAttribute"}):
					print "fix internal"
					PatchInternal(assembly)
			for reference in assembly.MainModule.AssemblyReferences:
				version as Version
				if assemblyNames.Contains(reference.Name):
					version = assemblyNames[reference.Name].First().Name.Version
				continue unless version
				reference.HasPublicKey = false
				reference.PublicKey = (of byte:,)
				reference.Version = version
				print "fix ref $reference"
			assembly.Write(file)
		except e:
			print file
			print e

task "patch:internal":
	name = Configuration.name.ToString()
	assembly = AssemblyDefinition.ReadAssembly(name)
	RemoveStrongName(assembly)
	PatchInternal(assembly)
	assembly.Write(name)

task "assembly:remove:strongname":
	name = Configuration.name.ToString()
	assembly = AssemblyDefinition.ReadAssembly(name)
	RemoveStrongName(assembly)
	assembly.Write(name)
